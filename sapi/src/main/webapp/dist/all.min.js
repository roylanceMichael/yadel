/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(24);
	__webpack_require__(25);
	__webpack_require__(3);
	__webpack_require__(27);
	__webpack_require__(23);
	__webpack_require__(2);
	__webpack_require__(28);
	__webpack_require__(29);
	module.exports = __webpack_require__(26);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var local_url_1 = __webpack_require__(2);
	var main_1 = __webpack_require__(3);
	var dag_1 = __webpack_require__(23);
	// this file won't be overwritten, add more dependencies for angular as needed
	function furtherAngularSetup(app) {
	    var localUrlService = new local_url_1.LocalUrlService();
	    var mainControllerName = "mainController";
	    app.config(function ($routeProvider) {
	        $routeProvider
	            .when(localUrlService.main, {
	            templateUrl: "views/main.html",
	            controller: mainControllerName
	        })
	            .otherwise({
	            redirectTo: localUrlService.main
	        });
	    });
	    app.factory("dagService", function ($window, $http) {
	        return new dag_1.DagService();
	    });
	    app.controller(mainControllerName, ['$scope', '$http', '$log', 'httpExecute', 'dagService', 'reportService',
	        function ($scope, $http, $log, httpExecute, dagService, reportService) {
	            $scope.i = new main_1.MainController(reportService, dagService);
	        }]);
	}
	exports.furtherAngularSetup = furtherAngularSetup;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var LocalUrlService = (function () {
	    function LocalUrlService() {
	        this.main = "/main";
	    }
	    return LocalUrlService;
	}());
	exports.LocalUrlService = LocalUrlService;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var YadelModel_1 = __webpack_require__(4);
	var MainController = (function () {
	    function MainController(reportService, dagService) {
	        this.dagReportNameSpace = "org.roylance.yadel.api.models.UIDagReport";
	        this.reportService = reportService;
	        this.dagService = dagService;
	        this.refresh();
	    }
	    MainController.prototype.refresh = function () {
	        var self = this;
	        this.selectedDag = null;
	        this.currentDagReport = null;
	        var request = new YadelModel_1.org.roylance.yadel.UIYadelRequest();
	        this.reportService.current(request, function (response) {
	            self.currentDagReport = response.report;
	            if (self.currentDagReport.dags.length > 0) {
	                self.selectedDag = self.currentDagReport.dags[0];
	                self.onDagChange();
	            }
	        }, function (response) {
	            self.onDagChange();
	        });
	    };
	    MainController.prototype.onDagChange = function () {
	        if (this.selectedDag) {
	            this.dagService.buildTreeVisualization(this.selectedDag);
	        }
	    };
	    MainController.prototype.deleteDag = function () {
	        if (this.selectedDag) {
	            // delete the dag
	            var self_1 = this;
	            var request = new YadelModel_1.org.roylance.yadel.UIYadelRequest();
	            request.requestType = YadelModel_1.org.roylance.yadel.UIYadelRequestType.DELETE_DAG;
	            request.dagId = this.selectedDag.id;
	            this.reportService.delete_dag(request, function (response) {
	                self_1.refresh();
	            }, function (data) {
	                console.log(data);
	                self_1.refresh();
	            });
	        }
	    };
	    return MainController;
	}());
	exports.MainController = MainController;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
	"use strict";

	var $protobuf = __webpack_require__(5);

	// Common aliases
	var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

	// Exported root namespace
	var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

	$root.org = (function() {

	    /**
	     * Namespace org.
	     * @exports org
	     * @namespace
	     */
	    var org = {};

	    org.roylance = (function() {

	        /**
	         * Namespace roylance.
	         * @memberof org
	         * @namespace
	         */
	        var roylance = {};

	        roylance.yadel = (function() {

	            /**
	             * Namespace yadel.
	             * @memberof org.roylance
	             * @namespace
	             */
	            var yadel = {};

	            yadel.CommonAction = (function() {

	                /**
	                 * Properties of a CommonAction.
	                 * @memberof org.roylance.yadel
	                 * @interface ICommonAction
	                 * @property {org.roylance.yadel.IUIYadelRequest} [request] CommonAction request
	                 * @property {org.roylance.yadel.IUIYadelResponse} [response] CommonAction response
	                 */

	                /**
	                 * Constructs a new CommonAction.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a CommonAction.
	                 * @constructor
	                 * @param {org.roylance.yadel.ICommonAction=} [properties] Properties to set
	                 */
	                function CommonAction(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * CommonAction request.
	                 * @member {(org.roylance.yadel.IUIYadelRequest|null|undefined)}request
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @instance
	                 */
	                CommonAction.prototype.request = null;

	                /**
	                 * CommonAction response.
	                 * @member {(org.roylance.yadel.IUIYadelResponse|null|undefined)}response
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @instance
	                 */
	                CommonAction.prototype.response = null;

	                /**
	                 * Creates a new CommonAction instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {org.roylance.yadel.ICommonAction=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.CommonAction} CommonAction instance
	                 */
	                CommonAction.create = function create(properties) {
	                    return new CommonAction(properties);
	                };

	                /**
	                 * Encodes the specified CommonAction message. Does not implicitly {@link org.roylance.yadel.CommonAction.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {org.roylance.yadel.ICommonAction} message CommonAction message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                CommonAction.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.request != null && message.hasOwnProperty("request"))
	                        $root.org.roylance.yadel.UIYadelRequest.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
	                    if (message.response != null && message.hasOwnProperty("response"))
	                        $root.org.roylance.yadel.UIYadelResponse.encode(message.response, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified CommonAction message, length delimited. Does not implicitly {@link org.roylance.yadel.CommonAction.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {org.roylance.yadel.ICommonAction} message CommonAction message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                CommonAction.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a CommonAction message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.CommonAction} CommonAction
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                CommonAction.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.CommonAction();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.request = $root.org.roylance.yadel.UIYadelRequest.decode(reader, reader.uint32());
	                            break;
	                        case 2:
	                            message.response = $root.org.roylance.yadel.UIYadelResponse.decode(reader, reader.uint32());
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a CommonAction message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.CommonAction} CommonAction
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                CommonAction.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a CommonAction message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                CommonAction.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.request != null && message.hasOwnProperty("request")) {
	                        var error = $root.org.roylance.yadel.UIYadelRequest.verify(message.request);
	                        if (error)
	                            return "request." + error;
	                    }
	                    if (message.response != null && message.hasOwnProperty("response")) {
	                        error = $root.org.roylance.yadel.UIYadelResponse.verify(message.response);
	                        if (error)
	                            return "response." + error;
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a CommonAction message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.CommonAction} CommonAction
	                 */
	                CommonAction.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.CommonAction)
	                        return object;
	                    var message = new $root.org.roylance.yadel.CommonAction();
	                    if (object.request != null) {
	                        if (typeof object.request !== "object")
	                            throw TypeError(".org.roylance.yadel.CommonAction.request: object expected");
	                        message.request = $root.org.roylance.yadel.UIYadelRequest.fromObject(object.request);
	                    }
	                    if (object.response != null) {
	                        if (typeof object.response !== "object")
	                            throw TypeError(".org.roylance.yadel.CommonAction.response: object expected");
	                        message.response = $root.org.roylance.yadel.UIYadelResponse.fromObject(object.response);
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a CommonAction message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @static
	                 * @param {org.roylance.yadel.CommonAction} message CommonAction
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                CommonAction.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.request = null;
	                        object.response = null;
	                    }
	                    if (message.request != null && message.hasOwnProperty("request"))
	                        object.request = $root.org.roylance.yadel.UIYadelRequest.toObject(message.request, options);
	                    if (message.response != null && message.hasOwnProperty("response"))
	                        object.response = $root.org.roylance.yadel.UIYadelResponse.toObject(message.response, options);
	                    return object;
	                };

	                /**
	                 * Converts this CommonAction to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.CommonAction
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                CommonAction.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return CommonAction;
	            })();

	            yadel.ReportController = (function() {

	                /**
	                 * Properties of a ReportController.
	                 * @memberof org.roylance.yadel
	                 * @interface IReportController
	                 * @property {org.roylance.yadel.ICommonAction} [deleteDag] ReportController deleteDag
	                 * @property {org.roylance.yadel.ICommonAction} [current] ReportController current
	                 * @property {org.roylance.yadel.ICommonAction} [getDagStatus] ReportController getDagStatus
	                 */

	                /**
	                 * Constructs a new ReportController.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a ReportController.
	                 * @constructor
	                 * @param {org.roylance.yadel.IReportController=} [properties] Properties to set
	                 */
	                function ReportController(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * ReportController deleteDag.
	                 * @member {(org.roylance.yadel.ICommonAction|null|undefined)}deleteDag
	                 * @memberof org.roylance.yadel.ReportController
	                 * @instance
	                 */
	                ReportController.prototype.deleteDag = null;

	                /**
	                 * ReportController current.
	                 * @member {(org.roylance.yadel.ICommonAction|null|undefined)}current
	                 * @memberof org.roylance.yadel.ReportController
	                 * @instance
	                 */
	                ReportController.prototype.current = null;

	                /**
	                 * ReportController getDagStatus.
	                 * @member {(org.roylance.yadel.ICommonAction|null|undefined)}getDagStatus
	                 * @memberof org.roylance.yadel.ReportController
	                 * @instance
	                 */
	                ReportController.prototype.getDagStatus = null;

	                /**
	                 * Creates a new ReportController instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {org.roylance.yadel.IReportController=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.ReportController} ReportController instance
	                 */
	                ReportController.create = function create(properties) {
	                    return new ReportController(properties);
	                };

	                /**
	                 * Encodes the specified ReportController message. Does not implicitly {@link org.roylance.yadel.ReportController.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {org.roylance.yadel.IReportController} message ReportController message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                ReportController.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.deleteDag != null && message.hasOwnProperty("deleteDag"))
	                        $root.org.roylance.yadel.CommonAction.encode(message.deleteDag, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
	                    if (message.current != null && message.hasOwnProperty("current"))
	                        $root.org.roylance.yadel.CommonAction.encode(message.current, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.getDagStatus != null && message.hasOwnProperty("getDagStatus"))
	                        $root.org.roylance.yadel.CommonAction.encode(message.getDagStatus, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified ReportController message, length delimited. Does not implicitly {@link org.roylance.yadel.ReportController.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {org.roylance.yadel.IReportController} message ReportController message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                ReportController.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a ReportController message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.ReportController} ReportController
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                ReportController.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.ReportController();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.deleteDag = $root.org.roylance.yadel.CommonAction.decode(reader, reader.uint32());
	                            break;
	                        case 2:
	                            message.current = $root.org.roylance.yadel.CommonAction.decode(reader, reader.uint32());
	                            break;
	                        case 3:
	                            message.getDagStatus = $root.org.roylance.yadel.CommonAction.decode(reader, reader.uint32());
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a ReportController message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.ReportController} ReportController
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                ReportController.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a ReportController message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                ReportController.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.deleteDag != null && message.hasOwnProperty("deleteDag")) {
	                        var error = $root.org.roylance.yadel.CommonAction.verify(message.deleteDag);
	                        if (error)
	                            return "deleteDag." + error;
	                    }
	                    if (message.current != null && message.hasOwnProperty("current")) {
	                        error = $root.org.roylance.yadel.CommonAction.verify(message.current);
	                        if (error)
	                            return "current." + error;
	                    }
	                    if (message.getDagStatus != null && message.hasOwnProperty("getDagStatus")) {
	                        error = $root.org.roylance.yadel.CommonAction.verify(message.getDagStatus);
	                        if (error)
	                            return "getDagStatus." + error;
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a ReportController message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.ReportController} ReportController
	                 */
	                ReportController.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.ReportController)
	                        return object;
	                    var message = new $root.org.roylance.yadel.ReportController();
	                    if (object.deleteDag != null) {
	                        if (typeof object.deleteDag !== "object")
	                            throw TypeError(".org.roylance.yadel.ReportController.deleteDag: object expected");
	                        message.deleteDag = $root.org.roylance.yadel.CommonAction.fromObject(object.deleteDag);
	                    }
	                    if (object.current != null) {
	                        if (typeof object.current !== "object")
	                            throw TypeError(".org.roylance.yadel.ReportController.current: object expected");
	                        message.current = $root.org.roylance.yadel.CommonAction.fromObject(object.current);
	                    }
	                    if (object.getDagStatus != null) {
	                        if (typeof object.getDagStatus !== "object")
	                            throw TypeError(".org.roylance.yadel.ReportController.getDagStatus: object expected");
	                        message.getDagStatus = $root.org.roylance.yadel.CommonAction.fromObject(object.getDagStatus);
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a ReportController message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.ReportController
	                 * @static
	                 * @param {org.roylance.yadel.ReportController} message ReportController
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                ReportController.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.deleteDag = null;
	                        object.current = null;
	                        object.getDagStatus = null;
	                    }
	                    if (message.deleteDag != null && message.hasOwnProperty("deleteDag"))
	                        object.deleteDag = $root.org.roylance.yadel.CommonAction.toObject(message.deleteDag, options);
	                    if (message.current != null && message.hasOwnProperty("current"))
	                        object.current = $root.org.roylance.yadel.CommonAction.toObject(message.current, options);
	                    if (message.getDagStatus != null && message.hasOwnProperty("getDagStatus"))
	                        object.getDagStatus = $root.org.roylance.yadel.CommonAction.toObject(message.getDagStatus, options);
	                    return object;
	                };

	                /**
	                 * Converts this ReportController to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.ReportController
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                ReportController.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return ReportController;
	            })();

	            /**
	             * UIYadelRequestType enum.
	             * @enum {string}
	             * @property {number} REPORT_DAGS=0 REPORT_DAGS value
	             * @property {number} DELETE_DAG=1 DELETE_DAG value
	             * @property {number} GET_DAG_STATUS=2 GET_DAG_STATUS value
	             * @property {number} REPORT_DAGS_ACTIVE=3 REPORT_DAGS_ACTIVE value
	             */
	            yadel.UIYadelRequestType = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "REPORT_DAGS"] = 0;
	                values[valuesById[1] = "DELETE_DAG"] = 1;
	                values[valuesById[2] = "GET_DAG_STATUS"] = 2;
	                values[valuesById[3] = "REPORT_DAGS_ACTIVE"] = 3;
	                return values;
	            })();

	            yadel.UIYadelRequest = (function() {

	                /**
	                 * Properties of a UIYadelRequest.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIYadelRequest
	                 * @property {org.roylance.yadel.UIYadelRequestType} [requestType] UIYadelRequest requestType
	                 * @property {string} [dagId] UIYadelRequest dagId
	                 * @property {string} [token] UIYadelRequest token
	                 * @property {string} [userName] UIYadelRequest userName
	                 * @property {string} [password] UIYadelRequest password
	                 */

	                /**
	                 * Constructs a new UIYadelRequest.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIYadelRequest.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIYadelRequest=} [properties] Properties to set
	                 */
	                function UIYadelRequest(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIYadelRequest requestType.
	                 * @member {org.roylance.yadel.UIYadelRequestType}requestType
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 */
	                UIYadelRequest.prototype.requestType = 0;

	                /**
	                 * UIYadelRequest dagId.
	                 * @member {string}dagId
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 */
	                UIYadelRequest.prototype.dagId = "";

	                /**
	                 * UIYadelRequest token.
	                 * @member {string}token
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 */
	                UIYadelRequest.prototype.token = "";

	                /**
	                 * UIYadelRequest userName.
	                 * @member {string}userName
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 */
	                UIYadelRequest.prototype.userName = "";

	                /**
	                 * UIYadelRequest password.
	                 * @member {string}password
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 */
	                UIYadelRequest.prototype.password = "";

	                /**
	                 * Creates a new UIYadelRequest instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelRequest=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIYadelRequest} UIYadelRequest instance
	                 */
	                UIYadelRequest.create = function create(properties) {
	                    return new UIYadelRequest(properties);
	                };

	                /**
	                 * Encodes the specified UIYadelRequest message. Does not implicitly {@link org.roylance.yadel.UIYadelRequest.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelRequest} message UIYadelRequest message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIYadelRequest.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.requestType != null && message.hasOwnProperty("requestType"))
	                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.requestType);
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.dagId);
	                    if (message.token != null && message.hasOwnProperty("token"))
	                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
	                    if (message.userName != null && message.hasOwnProperty("userName"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.userName);
	                    if (message.password != null && message.hasOwnProperty("password"))
	                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIYadelRequest message, length delimited. Does not implicitly {@link org.roylance.yadel.UIYadelRequest.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelRequest} message UIYadelRequest message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIYadelRequest.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIYadelRequest message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIYadelRequest} UIYadelRequest
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIYadelRequest.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIYadelRequest();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.requestType = reader.int32();
	                            break;
	                        case 2:
	                            message.dagId = reader.string();
	                            break;
	                        case 3:
	                            message.token = reader.string();
	                            break;
	                        case 4:
	                            message.userName = reader.string();
	                            break;
	                        case 5:
	                            message.password = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIYadelRequest message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIYadelRequest} UIYadelRequest
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIYadelRequest.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIYadelRequest message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIYadelRequest.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.requestType != null && message.hasOwnProperty("requestType"))
	                        switch (message.requestType) {
	                        default:
	                            return "requestType: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                            break;
	                        }
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        if (!$util.isString(message.dagId))
	                            return "dagId: string expected";
	                    if (message.token != null && message.hasOwnProperty("token"))
	                        if (!$util.isString(message.token))
	                            return "token: string expected";
	                    if (message.userName != null && message.hasOwnProperty("userName"))
	                        if (!$util.isString(message.userName))
	                            return "userName: string expected";
	                    if (message.password != null && message.hasOwnProperty("password"))
	                        if (!$util.isString(message.password))
	                            return "password: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a UIYadelRequest message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIYadelRequest} UIYadelRequest
	                 */
	                UIYadelRequest.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIYadelRequest)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIYadelRequest();
	                    switch (object.requestType) {
	                    case "REPORT_DAGS":
	                    case 0:
	                        message.requestType = 0;
	                        break;
	                    case "DELETE_DAG":
	                    case 1:
	                        message.requestType = 1;
	                        break;
	                    case "GET_DAG_STATUS":
	                    case 2:
	                        message.requestType = 2;
	                        break;
	                    case "REPORT_DAGS_ACTIVE":
	                    case 3:
	                        message.requestType = 3;
	                        break;
	                    }
	                    if (object.dagId != null)
	                        message.dagId = String(object.dagId);
	                    if (object.token != null)
	                        message.token = String(object.token);
	                    if (object.userName != null)
	                        message.userName = String(object.userName);
	                    if (object.password != null)
	                        message.password = String(object.password);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIYadelRequest message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @static
	                 * @param {org.roylance.yadel.UIYadelRequest} message UIYadelRequest
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIYadelRequest.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.requestType = options.enums === String ? "REPORT_DAGS" : 0;
	                        object.dagId = "";
	                        object.token = "";
	                        object.userName = "";
	                        object.password = "";
	                    }
	                    if (message.requestType != null && message.hasOwnProperty("requestType"))
	                        object.requestType = options.enums === String ? $root.org.roylance.yadel.UIYadelRequestType[message.requestType] : message.requestType;
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        object.dagId = message.dagId;
	                    if (message.token != null && message.hasOwnProperty("token"))
	                        object.token = message.token;
	                    if (message.userName != null && message.hasOwnProperty("userName"))
	                        object.userName = message.userName;
	                    if (message.password != null && message.hasOwnProperty("password"))
	                        object.password = message.password;
	                    return object;
	                };

	                /**
	                 * Converts this UIYadelRequest to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIYadelRequest
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIYadelRequest.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIYadelRequest;
	            })();

	            yadel.UIYadelResponse = (function() {

	                /**
	                 * Properties of a UIYadelResponse.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIYadelResponse
	                 * @property {string} [content] UIYadelResponse content
	                 * @property {org.roylance.yadel.IUIDagReport} [report] UIYadelResponse report
	                 * @property {org.roylance.yadel.IUIDag} [dag] UIYadelResponse dag
	                 * @property {Array.<org.roylance.yadel.IUIWorkerConfiguration>} [configurations] UIYadelResponse configurations
	                 */

	                /**
	                 * Constructs a new UIYadelResponse.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIYadelResponse.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIYadelResponse=} [properties] Properties to set
	                 */
	                function UIYadelResponse(properties) {
	                    this.configurations = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIYadelResponse content.
	                 * @member {string}content
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @instance
	                 */
	                UIYadelResponse.prototype.content = "";

	                /**
	                 * UIYadelResponse report.
	                 * @member {(org.roylance.yadel.IUIDagReport|null|undefined)}report
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @instance
	                 */
	                UIYadelResponse.prototype.report = null;

	                /**
	                 * UIYadelResponse dag.
	                 * @member {(org.roylance.yadel.IUIDag|null|undefined)}dag
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @instance
	                 */
	                UIYadelResponse.prototype.dag = null;

	                /**
	                 * UIYadelResponse configurations.
	                 * @member {Array.<org.roylance.yadel.IUIWorkerConfiguration>}configurations
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @instance
	                 */
	                UIYadelResponse.prototype.configurations = $util.emptyArray;

	                /**
	                 * Creates a new UIYadelResponse instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelResponse=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIYadelResponse} UIYadelResponse instance
	                 */
	                UIYadelResponse.create = function create(properties) {
	                    return new UIYadelResponse(properties);
	                };

	                /**
	                 * Encodes the specified UIYadelResponse message. Does not implicitly {@link org.roylance.yadel.UIYadelResponse.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelResponse} message UIYadelResponse message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIYadelResponse.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.content != null && message.hasOwnProperty("content"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
	                    if (message.report != null && message.hasOwnProperty("report"))
	                        $root.org.roylance.yadel.UIDagReport.encode(message.report, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.dag != null && message.hasOwnProperty("dag"))
	                        $root.org.roylance.yadel.UIDag.encode(message.dag, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.configurations != null && message.configurations.length)
	                        for (var i = 0; i < message.configurations.length; ++i)
	                            $root.org.roylance.yadel.UIWorkerConfiguration.encode(message.configurations[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIYadelResponse message, length delimited. Does not implicitly {@link org.roylance.yadel.UIYadelResponse.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {org.roylance.yadel.IUIYadelResponse} message UIYadelResponse message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIYadelResponse.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIYadelResponse message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIYadelResponse} UIYadelResponse
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIYadelResponse.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIYadelResponse();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.content = reader.string();
	                            break;
	                        case 2:
	                            message.report = $root.org.roylance.yadel.UIDagReport.decode(reader, reader.uint32());
	                            break;
	                        case 3:
	                            message.dag = $root.org.roylance.yadel.UIDag.decode(reader, reader.uint32());
	                            break;
	                        case 4:
	                            if (!(message.configurations && message.configurations.length))
	                                message.configurations = [];
	                            message.configurations.push($root.org.roylance.yadel.UIWorkerConfiguration.decode(reader, reader.uint32()));
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIYadelResponse message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIYadelResponse} UIYadelResponse
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIYadelResponse.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIYadelResponse message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIYadelResponse.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.content != null && message.hasOwnProperty("content"))
	                        if (!$util.isString(message.content))
	                            return "content: string expected";
	                    if (message.report != null && message.hasOwnProperty("report")) {
	                        var error = $root.org.roylance.yadel.UIDagReport.verify(message.report);
	                        if (error)
	                            return "report." + error;
	                    }
	                    if (message.dag != null && message.hasOwnProperty("dag")) {
	                        error = $root.org.roylance.yadel.UIDag.verify(message.dag);
	                        if (error)
	                            return "dag." + error;
	                    }
	                    if (message.configurations != null && message.hasOwnProperty("configurations")) {
	                        if (!Array.isArray(message.configurations))
	                            return "configurations: array expected";
	                        for (var i = 0; i < message.configurations.length; ++i) {
	                            error = $root.org.roylance.yadel.UIWorkerConfiguration.verify(message.configurations[i]);
	                            if (error)
	                                return "configurations." + error;
	                        }
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a UIYadelResponse message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIYadelResponse} UIYadelResponse
	                 */
	                UIYadelResponse.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIYadelResponse)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIYadelResponse();
	                    if (object.content != null)
	                        message.content = String(object.content);
	                    if (object.report != null) {
	                        if (typeof object.report !== "object")
	                            throw TypeError(".org.roylance.yadel.UIYadelResponse.report: object expected");
	                        message.report = $root.org.roylance.yadel.UIDagReport.fromObject(object.report);
	                    }
	                    if (object.dag != null) {
	                        if (typeof object.dag !== "object")
	                            throw TypeError(".org.roylance.yadel.UIYadelResponse.dag: object expected");
	                        message.dag = $root.org.roylance.yadel.UIDag.fromObject(object.dag);
	                    }
	                    if (object.configurations) {
	                        if (!Array.isArray(object.configurations))
	                            throw TypeError(".org.roylance.yadel.UIYadelResponse.configurations: array expected");
	                        message.configurations = [];
	                        for (var i = 0; i < object.configurations.length; ++i) {
	                            if (typeof object.configurations[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIYadelResponse.configurations: object expected");
	                            message.configurations[i] = $root.org.roylance.yadel.UIWorkerConfiguration.fromObject(object.configurations[i]);
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIYadelResponse message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @static
	                 * @param {org.roylance.yadel.UIYadelResponse} message UIYadelResponse
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIYadelResponse.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults)
	                        object.configurations = [];
	                    if (options.defaults) {
	                        object.content = "";
	                        object.report = null;
	                        object.dag = null;
	                    }
	                    if (message.content != null && message.hasOwnProperty("content"))
	                        object.content = message.content;
	                    if (message.report != null && message.hasOwnProperty("report"))
	                        object.report = $root.org.roylance.yadel.UIDagReport.toObject(message.report, options);
	                    if (message.dag != null && message.hasOwnProperty("dag"))
	                        object.dag = $root.org.roylance.yadel.UIDag.toObject(message.dag, options);
	                    if (message.configurations && message.configurations.length) {
	                        object.configurations = [];
	                        for (var j = 0; j < message.configurations.length; ++j)
	                            object.configurations[j] = $root.org.roylance.yadel.UIWorkerConfiguration.toObject(message.configurations[j], options);
	                    }
	                    return object;
	                };

	                /**
	                 * Converts this UIYadelResponse to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIYadelResponse
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIYadelResponse.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIYadelResponse;
	            })();

	            yadel.UIDagReport = (function() {

	                /**
	                 * Properties of a UIDagReport.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIDagReport
	                 * @property {Array.<org.roylance.yadel.IUIWorkerConfiguration>} [workers] UIDagReport workers
	                 * @property {Array.<org.roylance.yadel.IUIDag>} [dags] UIDagReport dags
	                 * @property {string} [usedManagerMemory] UIDagReport usedManagerMemory
	                 * @property {string} [totalManagerMemory] UIDagReport totalManagerMemory
	                 * @property {number} [activeDags] UIDagReport activeDags
	                 * @property {number} [unprocessedDags] UIDagReport unprocessedDags
	                 * @property {number} [savedDags] UIDagReport savedDags
	                 */

	                /**
	                 * Constructs a new UIDagReport.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIDagReport.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIDagReport=} [properties] Properties to set
	                 */
	                function UIDagReport(properties) {
	                    this.workers = [];
	                    this.dags = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIDagReport workers.
	                 * @member {Array.<org.roylance.yadel.IUIWorkerConfiguration>}workers
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.workers = $util.emptyArray;

	                /**
	                 * UIDagReport dags.
	                 * @member {Array.<org.roylance.yadel.IUIDag>}dags
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.dags = $util.emptyArray;

	                /**
	                 * UIDagReport usedManagerMemory.
	                 * @member {string}usedManagerMemory
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.usedManagerMemory = "";

	                /**
	                 * UIDagReport totalManagerMemory.
	                 * @member {string}totalManagerMemory
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.totalManagerMemory = "";

	                /**
	                 * UIDagReport activeDags.
	                 * @member {number}activeDags
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.activeDags = 0;

	                /**
	                 * UIDagReport unprocessedDags.
	                 * @member {number}unprocessedDags
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.unprocessedDags = 0;

	                /**
	                 * UIDagReport savedDags.
	                 * @member {number}savedDags
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 */
	                UIDagReport.prototype.savedDags = 0;

	                /**
	                 * Creates a new UIDagReport instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {org.roylance.yadel.IUIDagReport=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIDagReport} UIDagReport instance
	                 */
	                UIDagReport.create = function create(properties) {
	                    return new UIDagReport(properties);
	                };

	                /**
	                 * Encodes the specified UIDagReport message. Does not implicitly {@link org.roylance.yadel.UIDagReport.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {org.roylance.yadel.IUIDagReport} message UIDagReport message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIDagReport.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.workers != null && message.workers.length)
	                        for (var i = 0; i < message.workers.length; ++i)
	                            $root.org.roylance.yadel.UIWorkerConfiguration.encode(message.workers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
	                    if (message.dags != null && message.dags.length)
	                        for (var i = 0; i < message.dags.length; ++i)
	                            $root.org.roylance.yadel.UIDag.encode(message.dags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.usedManagerMemory != null && message.hasOwnProperty("usedManagerMemory"))
	                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.usedManagerMemory);
	                    if (message.totalManagerMemory != null && message.hasOwnProperty("totalManagerMemory"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.totalManagerMemory);
	                    if (message.activeDags != null && message.hasOwnProperty("activeDags"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.activeDags);
	                    if (message.unprocessedDags != null && message.hasOwnProperty("unprocessedDags"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.unprocessedDags);
	                    if (message.savedDags != null && message.hasOwnProperty("savedDags"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.savedDags);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIDagReport message, length delimited. Does not implicitly {@link org.roylance.yadel.UIDagReport.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {org.roylance.yadel.IUIDagReport} message UIDagReport message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIDagReport.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIDagReport message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIDagReport} UIDagReport
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIDagReport.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIDagReport();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            if (!(message.workers && message.workers.length))
	                                message.workers = [];
	                            message.workers.push($root.org.roylance.yadel.UIWorkerConfiguration.decode(reader, reader.uint32()));
	                            break;
	                        case 2:
	                            if (!(message.dags && message.dags.length))
	                                message.dags = [];
	                            message.dags.push($root.org.roylance.yadel.UIDag.decode(reader, reader.uint32()));
	                            break;
	                        case 3:
	                            message.usedManagerMemory = reader.string();
	                            break;
	                        case 4:
	                            message.totalManagerMemory = reader.string();
	                            break;
	                        case 5:
	                            message.activeDags = reader.int32();
	                            break;
	                        case 6:
	                            message.unprocessedDags = reader.int32();
	                            break;
	                        case 7:
	                            message.savedDags = reader.int32();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIDagReport message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIDagReport} UIDagReport
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIDagReport.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIDagReport message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIDagReport.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.workers != null && message.hasOwnProperty("workers")) {
	                        if (!Array.isArray(message.workers))
	                            return "workers: array expected";
	                        for (var i = 0; i < message.workers.length; ++i) {
	                            var error = $root.org.roylance.yadel.UIWorkerConfiguration.verify(message.workers[i]);
	                            if (error)
	                                return "workers." + error;
	                        }
	                    }
	                    if (message.dags != null && message.hasOwnProperty("dags")) {
	                        if (!Array.isArray(message.dags))
	                            return "dags: array expected";
	                        for (var i = 0; i < message.dags.length; ++i) {
	                            error = $root.org.roylance.yadel.UIDag.verify(message.dags[i]);
	                            if (error)
	                                return "dags." + error;
	                        }
	                    }
	                    if (message.usedManagerMemory != null && message.hasOwnProperty("usedManagerMemory"))
	                        if (!$util.isString(message.usedManagerMemory))
	                            return "usedManagerMemory: string expected";
	                    if (message.totalManagerMemory != null && message.hasOwnProperty("totalManagerMemory"))
	                        if (!$util.isString(message.totalManagerMemory))
	                            return "totalManagerMemory: string expected";
	                    if (message.activeDags != null && message.hasOwnProperty("activeDags"))
	                        if (!$util.isInteger(message.activeDags))
	                            return "activeDags: integer expected";
	                    if (message.unprocessedDags != null && message.hasOwnProperty("unprocessedDags"))
	                        if (!$util.isInteger(message.unprocessedDags))
	                            return "unprocessedDags: integer expected";
	                    if (message.savedDags != null && message.hasOwnProperty("savedDags"))
	                        if (!$util.isInteger(message.savedDags))
	                            return "savedDags: integer expected";
	                    return null;
	                };

	                /**
	                 * Creates a UIDagReport message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIDagReport} UIDagReport
	                 */
	                UIDagReport.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIDagReport)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIDagReport();
	                    if (object.workers) {
	                        if (!Array.isArray(object.workers))
	                            throw TypeError(".org.roylance.yadel.UIDagReport.workers: array expected");
	                        message.workers = [];
	                        for (var i = 0; i < object.workers.length; ++i) {
	                            if (typeof object.workers[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIDagReport.workers: object expected");
	                            message.workers[i] = $root.org.roylance.yadel.UIWorkerConfiguration.fromObject(object.workers[i]);
	                        }
	                    }
	                    if (object.dags) {
	                        if (!Array.isArray(object.dags))
	                            throw TypeError(".org.roylance.yadel.UIDagReport.dags: array expected");
	                        message.dags = [];
	                        for (var i = 0; i < object.dags.length; ++i) {
	                            if (typeof object.dags[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIDagReport.dags: object expected");
	                            message.dags[i] = $root.org.roylance.yadel.UIDag.fromObject(object.dags[i]);
	                        }
	                    }
	                    if (object.usedManagerMemory != null)
	                        message.usedManagerMemory = String(object.usedManagerMemory);
	                    if (object.totalManagerMemory != null)
	                        message.totalManagerMemory = String(object.totalManagerMemory);
	                    if (object.activeDags != null)
	                        message.activeDags = object.activeDags | 0;
	                    if (object.unprocessedDags != null)
	                        message.unprocessedDags = object.unprocessedDags | 0;
	                    if (object.savedDags != null)
	                        message.savedDags = object.savedDags | 0;
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIDagReport message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @static
	                 * @param {org.roylance.yadel.UIDagReport} message UIDagReport
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIDagReport.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults) {
	                        object.workers = [];
	                        object.dags = [];
	                    }
	                    if (options.defaults) {
	                        object.usedManagerMemory = "";
	                        object.totalManagerMemory = "";
	                        object.activeDags = 0;
	                        object.unprocessedDags = 0;
	                        object.savedDags = 0;
	                    }
	                    if (message.workers && message.workers.length) {
	                        object.workers = [];
	                        for (var j = 0; j < message.workers.length; ++j)
	                            object.workers[j] = $root.org.roylance.yadel.UIWorkerConfiguration.toObject(message.workers[j], options);
	                    }
	                    if (message.dags && message.dags.length) {
	                        object.dags = [];
	                        for (var j = 0; j < message.dags.length; ++j)
	                            object.dags[j] = $root.org.roylance.yadel.UIDag.toObject(message.dags[j], options);
	                    }
	                    if (message.usedManagerMemory != null && message.hasOwnProperty("usedManagerMemory"))
	                        object.usedManagerMemory = message.usedManagerMemory;
	                    if (message.totalManagerMemory != null && message.hasOwnProperty("totalManagerMemory"))
	                        object.totalManagerMemory = message.totalManagerMemory;
	                    if (message.activeDags != null && message.hasOwnProperty("activeDags"))
	                        object.activeDags = message.activeDags;
	                    if (message.unprocessedDags != null && message.hasOwnProperty("unprocessedDags"))
	                        object.unprocessedDags = message.unprocessedDags;
	                    if (message.savedDags != null && message.hasOwnProperty("savedDags"))
	                        object.savedDags = message.savedDags;
	                    return object;
	                };

	                /**
	                 * Converts this UIDagReport to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIDagReport
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIDagReport.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIDagReport;
	            })();

	            yadel.UIDag = (function() {

	                /**
	                 * Properties of a UIDag.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIDag
	                 * @property {string} [id] UIDag id
	                 * @property {string} [display] UIDag display
	                 * @property {Array.<org.roylance.yadel.IUINode>} [nodes] UIDag nodes
	                 * @property {Array.<org.roylance.yadel.IUIEdge>} [edges] UIDag edges
	                 * @property {boolean} [isCompleted] UIDag isCompleted
	                 * @property {boolean} [isProcessing] UIDag isProcessing
	                 * @property {boolean} [isError] UIDag isError
	                 * @property {Array.<string>} [logs] UIDag logs
	                 * @property {number} [numberCompleted] UIDag numberCompleted
	                 * @property {number} [numberProcessing] UIDag numberProcessing
	                 * @property {number} [numberErrored] UIDag numberErrored
	                 * @property {number} [numberUnprocessed] UIDag numberUnprocessed
	                 * @property {Array.<org.roylance.yadel.IUIDag>} [children] UIDag children
	                 */

	                /**
	                 * Constructs a new UIDag.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIDag.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIDag=} [properties] Properties to set
	                 */
	                function UIDag(properties) {
	                    this.nodes = [];
	                    this.edges = [];
	                    this.logs = [];
	                    this.children = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIDag id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.id = "";

	                /**
	                 * UIDag display.
	                 * @member {string}display
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.display = "";

	                /**
	                 * UIDag nodes.
	                 * @member {Array.<org.roylance.yadel.IUINode>}nodes
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.nodes = $util.emptyArray;

	                /**
	                 * UIDag edges.
	                 * @member {Array.<org.roylance.yadel.IUIEdge>}edges
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.edges = $util.emptyArray;

	                /**
	                 * UIDag isCompleted.
	                 * @member {boolean}isCompleted
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.isCompleted = false;

	                /**
	                 * UIDag isProcessing.
	                 * @member {boolean}isProcessing
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.isProcessing = false;

	                /**
	                 * UIDag isError.
	                 * @member {boolean}isError
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.isError = false;

	                /**
	                 * UIDag logs.
	                 * @member {Array.<string>}logs
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.logs = $util.emptyArray;

	                /**
	                 * UIDag numberCompleted.
	                 * @member {number}numberCompleted
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.numberCompleted = 0;

	                /**
	                 * UIDag numberProcessing.
	                 * @member {number}numberProcessing
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.numberProcessing = 0;

	                /**
	                 * UIDag numberErrored.
	                 * @member {number}numberErrored
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.numberErrored = 0;

	                /**
	                 * UIDag numberUnprocessed.
	                 * @member {number}numberUnprocessed
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.numberUnprocessed = 0;

	                /**
	                 * UIDag children.
	                 * @member {Array.<org.roylance.yadel.IUIDag>}children
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 */
	                UIDag.prototype.children = $util.emptyArray;

	                /**
	                 * Creates a new UIDag instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {org.roylance.yadel.IUIDag=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIDag} UIDag instance
	                 */
	                UIDag.create = function create(properties) {
	                    return new UIDag(properties);
	                };

	                /**
	                 * Encodes the specified UIDag message. Does not implicitly {@link org.roylance.yadel.UIDag.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {org.roylance.yadel.IUIDag} message UIDag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIDag.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.display);
	                    if (message.nodes != null && message.nodes.length)
	                        for (var i = 0; i < message.nodes.length; ++i)
	                            $root.org.roylance.yadel.UINode.encode(message.nodes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.edges != null && message.edges.length)
	                        for (var i = 0; i < message.edges.length; ++i)
	                            $root.org.roylance.yadel.UIEdge.encode(message.edges[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isCompleted);
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isProcessing);
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isError);
	                    if (message.logs != null && message.logs.length)
	                        for (var i = 0; i < message.logs.length; ++i)
	                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.logs[i]);
	                    if (message.numberCompleted != null && message.hasOwnProperty("numberCompleted"))
	                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.numberCompleted);
	                    if (message.numberProcessing != null && message.hasOwnProperty("numberProcessing"))
	                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.numberProcessing);
	                    if (message.numberErrored != null && message.hasOwnProperty("numberErrored"))
	                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.numberErrored);
	                    if (message.numberUnprocessed != null && message.hasOwnProperty("numberUnprocessed"))
	                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.numberUnprocessed);
	                    if (message.children != null && message.children.length)
	                        for (var i = 0; i < message.children.length; ++i)
	                            $root.org.roylance.yadel.UIDag.encode(message.children[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIDag message, length delimited. Does not implicitly {@link org.roylance.yadel.UIDag.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {org.roylance.yadel.IUIDag} message UIDag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIDag.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIDag message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIDag} UIDag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIDag.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIDag();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.display = reader.string();
	                            break;
	                        case 3:
	                            if (!(message.nodes && message.nodes.length))
	                                message.nodes = [];
	                            message.nodes.push($root.org.roylance.yadel.UINode.decode(reader, reader.uint32()));
	                            break;
	                        case 4:
	                            if (!(message.edges && message.edges.length))
	                                message.edges = [];
	                            message.edges.push($root.org.roylance.yadel.UIEdge.decode(reader, reader.uint32()));
	                            break;
	                        case 5:
	                            message.isCompleted = reader.bool();
	                            break;
	                        case 6:
	                            message.isProcessing = reader.bool();
	                            break;
	                        case 7:
	                            message.isError = reader.bool();
	                            break;
	                        case 8:
	                            if (!(message.logs && message.logs.length))
	                                message.logs = [];
	                            message.logs.push(reader.string());
	                            break;
	                        case 9:
	                            message.numberCompleted = reader.int32();
	                            break;
	                        case 10:
	                            message.numberProcessing = reader.int32();
	                            break;
	                        case 11:
	                            message.numberErrored = reader.int32();
	                            break;
	                        case 12:
	                            message.numberUnprocessed = reader.int32();
	                            break;
	                        case 13:
	                            if (!(message.children && message.children.length))
	                                message.children = [];
	                            message.children.push($root.org.roylance.yadel.UIDag.decode(reader, reader.uint32()));
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIDag message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIDag} UIDag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIDag.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIDag message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIDag.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        if (!$util.isString(message.display))
	                            return "display: string expected";
	                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
	                        if (!Array.isArray(message.nodes))
	                            return "nodes: array expected";
	                        for (var i = 0; i < message.nodes.length; ++i) {
	                            var error = $root.org.roylance.yadel.UINode.verify(message.nodes[i]);
	                            if (error)
	                                return "nodes." + error;
	                        }
	                    }
	                    if (message.edges != null && message.hasOwnProperty("edges")) {
	                        if (!Array.isArray(message.edges))
	                            return "edges: array expected";
	                        for (var i = 0; i < message.edges.length; ++i) {
	                            error = $root.org.roylance.yadel.UIEdge.verify(message.edges[i]);
	                            if (error)
	                                return "edges." + error;
	                        }
	                    }
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        if (typeof message.isCompleted !== "boolean")
	                            return "isCompleted: boolean expected";
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        if (typeof message.isProcessing !== "boolean")
	                            return "isProcessing: boolean expected";
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        if (typeof message.isError !== "boolean")
	                            return "isError: boolean expected";
	                    if (message.logs != null && message.hasOwnProperty("logs")) {
	                        if (!Array.isArray(message.logs))
	                            return "logs: array expected";
	                        for (var i = 0; i < message.logs.length; ++i)
	                            if (!$util.isString(message.logs[i]))
	                                return "logs: string[] expected";
	                    }
	                    if (message.numberCompleted != null && message.hasOwnProperty("numberCompleted"))
	                        if (!$util.isInteger(message.numberCompleted))
	                            return "numberCompleted: integer expected";
	                    if (message.numberProcessing != null && message.hasOwnProperty("numberProcessing"))
	                        if (!$util.isInteger(message.numberProcessing))
	                            return "numberProcessing: integer expected";
	                    if (message.numberErrored != null && message.hasOwnProperty("numberErrored"))
	                        if (!$util.isInteger(message.numberErrored))
	                            return "numberErrored: integer expected";
	                    if (message.numberUnprocessed != null && message.hasOwnProperty("numberUnprocessed"))
	                        if (!$util.isInteger(message.numberUnprocessed))
	                            return "numberUnprocessed: integer expected";
	                    if (message.children != null && message.hasOwnProperty("children")) {
	                        if (!Array.isArray(message.children))
	                            return "children: array expected";
	                        for (var i = 0; i < message.children.length; ++i) {
	                            error = $root.org.roylance.yadel.UIDag.verify(message.children[i]);
	                            if (error)
	                                return "children." + error;
	                        }
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a UIDag message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIDag} UIDag
	                 */
	                UIDag.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIDag)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIDag();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.display != null)
	                        message.display = String(object.display);
	                    if (object.nodes) {
	                        if (!Array.isArray(object.nodes))
	                            throw TypeError(".org.roylance.yadel.UIDag.nodes: array expected");
	                        message.nodes = [];
	                        for (var i = 0; i < object.nodes.length; ++i) {
	                            if (typeof object.nodes[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIDag.nodes: object expected");
	                            message.nodes[i] = $root.org.roylance.yadel.UINode.fromObject(object.nodes[i]);
	                        }
	                    }
	                    if (object.edges) {
	                        if (!Array.isArray(object.edges))
	                            throw TypeError(".org.roylance.yadel.UIDag.edges: array expected");
	                        message.edges = [];
	                        for (var i = 0; i < object.edges.length; ++i) {
	                            if (typeof object.edges[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIDag.edges: object expected");
	                            message.edges[i] = $root.org.roylance.yadel.UIEdge.fromObject(object.edges[i]);
	                        }
	                    }
	                    if (object.isCompleted != null)
	                        message.isCompleted = Boolean(object.isCompleted);
	                    if (object.isProcessing != null)
	                        message.isProcessing = Boolean(object.isProcessing);
	                    if (object.isError != null)
	                        message.isError = Boolean(object.isError);
	                    if (object.logs) {
	                        if (!Array.isArray(object.logs))
	                            throw TypeError(".org.roylance.yadel.UIDag.logs: array expected");
	                        message.logs = [];
	                        for (var i = 0; i < object.logs.length; ++i)
	                            message.logs[i] = String(object.logs[i]);
	                    }
	                    if (object.numberCompleted != null)
	                        message.numberCompleted = object.numberCompleted | 0;
	                    if (object.numberProcessing != null)
	                        message.numberProcessing = object.numberProcessing | 0;
	                    if (object.numberErrored != null)
	                        message.numberErrored = object.numberErrored | 0;
	                    if (object.numberUnprocessed != null)
	                        message.numberUnprocessed = object.numberUnprocessed | 0;
	                    if (object.children) {
	                        if (!Array.isArray(object.children))
	                            throw TypeError(".org.roylance.yadel.UIDag.children: array expected");
	                        message.children = [];
	                        for (var i = 0; i < object.children.length; ++i) {
	                            if (typeof object.children[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UIDag.children: object expected");
	                            message.children[i] = $root.org.roylance.yadel.UIDag.fromObject(object.children[i]);
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIDag message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIDag
	                 * @static
	                 * @param {org.roylance.yadel.UIDag} message UIDag
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIDag.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults) {
	                        object.nodes = [];
	                        object.edges = [];
	                        object.logs = [];
	                        object.children = [];
	                    }
	                    if (options.defaults) {
	                        object.id = "";
	                        object.display = "";
	                        object.isCompleted = false;
	                        object.isProcessing = false;
	                        object.isError = false;
	                        object.numberCompleted = 0;
	                        object.numberProcessing = 0;
	                        object.numberErrored = 0;
	                        object.numberUnprocessed = 0;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        object.display = message.display;
	                    if (message.nodes && message.nodes.length) {
	                        object.nodes = [];
	                        for (var j = 0; j < message.nodes.length; ++j)
	                            object.nodes[j] = $root.org.roylance.yadel.UINode.toObject(message.nodes[j], options);
	                    }
	                    if (message.edges && message.edges.length) {
	                        object.edges = [];
	                        for (var j = 0; j < message.edges.length; ++j)
	                            object.edges[j] = $root.org.roylance.yadel.UIEdge.toObject(message.edges[j], options);
	                    }
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        object.isCompleted = message.isCompleted;
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        object.isProcessing = message.isProcessing;
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        object.isError = message.isError;
	                    if (message.logs && message.logs.length) {
	                        object.logs = [];
	                        for (var j = 0; j < message.logs.length; ++j)
	                            object.logs[j] = message.logs[j];
	                    }
	                    if (message.numberCompleted != null && message.hasOwnProperty("numberCompleted"))
	                        object.numberCompleted = message.numberCompleted;
	                    if (message.numberProcessing != null && message.hasOwnProperty("numberProcessing"))
	                        object.numberProcessing = message.numberProcessing;
	                    if (message.numberErrored != null && message.hasOwnProperty("numberErrored"))
	                        object.numberErrored = message.numberErrored;
	                    if (message.numberUnprocessed != null && message.hasOwnProperty("numberUnprocessed"))
	                        object.numberUnprocessed = message.numberUnprocessed;
	                    if (message.children && message.children.length) {
	                        object.children = [];
	                        for (var j = 0; j < message.children.length; ++j)
	                            object.children[j] = $root.org.roylance.yadel.UIDag.toObject(message.children[j], options);
	                    }
	                    return object;
	                };

	                /**
	                 * Converts this UIDag to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIDag
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIDag.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIDag;
	            })();

	            yadel.UIEdge = (function() {

	                /**
	                 * Properties of a UIEdge.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIEdge
	                 * @property {string} [nodeId_1] UIEdge nodeId_1
	                 * @property {string} [nodeId_2] UIEdge nodeId_2
	                 */

	                /**
	                 * Constructs a new UIEdge.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIEdge.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIEdge=} [properties] Properties to set
	                 */
	                function UIEdge(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIEdge nodeId_1.
	                 * @member {string}nodeId_1
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @instance
	                 */
	                UIEdge.prototype.nodeId_1 = "";

	                /**
	                 * UIEdge nodeId_2.
	                 * @member {string}nodeId_2
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @instance
	                 */
	                UIEdge.prototype.nodeId_2 = "";

	                /**
	                 * Creates a new UIEdge instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {org.roylance.yadel.IUIEdge=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIEdge} UIEdge instance
	                 */
	                UIEdge.create = function create(properties) {
	                    return new UIEdge(properties);
	                };

	                /**
	                 * Encodes the specified UIEdge message. Does not implicitly {@link org.roylance.yadel.UIEdge.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {org.roylance.yadel.IUIEdge} message UIEdge message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIEdge.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.nodeId_1 != null && message.hasOwnProperty("nodeId_1"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId_1);
	                    if (message.nodeId_2 != null && message.hasOwnProperty("nodeId_2"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodeId_2);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIEdge message, length delimited. Does not implicitly {@link org.roylance.yadel.UIEdge.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {org.roylance.yadel.IUIEdge} message UIEdge message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIEdge.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIEdge message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIEdge} UIEdge
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIEdge.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIEdge();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.nodeId_1 = reader.string();
	                            break;
	                        case 2:
	                            message.nodeId_2 = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIEdge message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIEdge} UIEdge
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIEdge.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIEdge message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIEdge.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.nodeId_1 != null && message.hasOwnProperty("nodeId_1"))
	                        if (!$util.isString(message.nodeId_1))
	                            return "nodeId_1: string expected";
	                    if (message.nodeId_2 != null && message.hasOwnProperty("nodeId_2"))
	                        if (!$util.isString(message.nodeId_2))
	                            return "nodeId_2: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a UIEdge message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIEdge} UIEdge
	                 */
	                UIEdge.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIEdge)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIEdge();
	                    if (object.nodeId_1 != null)
	                        message.nodeId_1 = String(object.nodeId_1);
	                    if (object.nodeId_2 != null)
	                        message.nodeId_2 = String(object.nodeId_2);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIEdge message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @static
	                 * @param {org.roylance.yadel.UIEdge} message UIEdge
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIEdge.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.nodeId_1 = "";
	                        object.nodeId_2 = "";
	                    }
	                    if (message.nodeId_1 != null && message.hasOwnProperty("nodeId_1"))
	                        object.nodeId_1 = message.nodeId_1;
	                    if (message.nodeId_2 != null && message.hasOwnProperty("nodeId_2"))
	                        object.nodeId_2 = message.nodeId_2;
	                    return object;
	                };

	                /**
	                 * Converts this UIEdge to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIEdge
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIEdge.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIEdge;
	            })();

	            yadel.UINode = (function() {

	                /**
	                 * Properties of a UINode.
	                 * @memberof org.roylance.yadel
	                 * @interface IUINode
	                 * @property {string} [id] UINode id
	                 * @property {string} [display] UINode display
	                 * @property {number|Long} [executionDate] UINode executionDate
	                 * @property {number|Long} [startDate] UINode startDate
	                 * @property {number|Long} [endDate] UINode endDate
	                 * @property {number|Long} [duration] UINode duration
	                 * @property {boolean} [isCompleted] UINode isCompleted
	                 * @property {boolean} [isProcessing] UINode isProcessing
	                 * @property {boolean} [isError] UINode isError
	                 * @property {Array.<org.roylance.yadel.IUILog>} [logs] UINode logs
	                 * @property {boolean} [isWaitingForAnotherDagTask] UINode isWaitingForAnotherDagTask
	                 */

	                /**
	                 * Constructs a new UINode.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UINode.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUINode=} [properties] Properties to set
	                 */
	                function UINode(properties) {
	                    this.logs = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UINode id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.id = "";

	                /**
	                 * UINode display.
	                 * @member {string}display
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.display = "";

	                /**
	                 * UINode executionDate.
	                 * @member {number|Long}executionDate
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.executionDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * UINode startDate.
	                 * @member {number|Long}startDate
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.startDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * UINode endDate.
	                 * @member {number|Long}endDate
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.endDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * UINode duration.
	                 * @member {number|Long}duration
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * UINode isCompleted.
	                 * @member {boolean}isCompleted
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.isCompleted = false;

	                /**
	                 * UINode isProcessing.
	                 * @member {boolean}isProcessing
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.isProcessing = false;

	                /**
	                 * UINode isError.
	                 * @member {boolean}isError
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.isError = false;

	                /**
	                 * UINode logs.
	                 * @member {Array.<org.roylance.yadel.IUILog>}logs
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.logs = $util.emptyArray;

	                /**
	                 * UINode isWaitingForAnotherDagTask.
	                 * @member {boolean}isWaitingForAnotherDagTask
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 */
	                UINode.prototype.isWaitingForAnotherDagTask = false;

	                /**
	                 * Creates a new UINode instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {org.roylance.yadel.IUINode=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UINode} UINode instance
	                 */
	                UINode.create = function create(properties) {
	                    return new UINode(properties);
	                };

	                /**
	                 * Encodes the specified UINode message. Does not implicitly {@link org.roylance.yadel.UINode.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {org.roylance.yadel.IUINode} message UINode message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UINode.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.display);
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.executionDate);
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startDate);
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.endDate);
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.duration);
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isCompleted);
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isProcessing);
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isError);
	                    if (message.logs != null && message.logs.length)
	                        for (var i = 0; i < message.logs.length; ++i)
	                            $root.org.roylance.yadel.UILog.encode(message.logs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.isWaitingForAnotherDagTask);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UINode message, length delimited. Does not implicitly {@link org.roylance.yadel.UINode.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {org.roylance.yadel.IUINode} message UINode message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UINode.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UINode message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UINode} UINode
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UINode.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UINode();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.display = reader.string();
	                            break;
	                        case 4:
	                            message.executionDate = reader.int64();
	                            break;
	                        case 5:
	                            message.startDate = reader.int64();
	                            break;
	                        case 6:
	                            message.endDate = reader.int64();
	                            break;
	                        case 7:
	                            message.duration = reader.int64();
	                            break;
	                        case 8:
	                            message.isCompleted = reader.bool();
	                            break;
	                        case 9:
	                            message.isProcessing = reader.bool();
	                            break;
	                        case 10:
	                            message.isError = reader.bool();
	                            break;
	                        case 11:
	                            if (!(message.logs && message.logs.length))
	                                message.logs = [];
	                            message.logs.push($root.org.roylance.yadel.UILog.decode(reader, reader.uint32()));
	                            break;
	                        case 12:
	                            message.isWaitingForAnotherDagTask = reader.bool();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UINode message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UINode} UINode
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UINode.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UINode message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UINode.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        if (!$util.isString(message.display))
	                            return "display: string expected";
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (!$util.isInteger(message.executionDate) && !(message.executionDate && $util.isInteger(message.executionDate.low) && $util.isInteger(message.executionDate.high)))
	                            return "executionDate: integer|Long expected";
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (!$util.isInteger(message.startDate) && !(message.startDate && $util.isInteger(message.startDate.low) && $util.isInteger(message.startDate.high)))
	                            return "startDate: integer|Long expected";
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (!$util.isInteger(message.endDate) && !(message.endDate && $util.isInteger(message.endDate.low) && $util.isInteger(message.endDate.high)))
	                            return "endDate: integer|Long expected";
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
	                            return "duration: integer|Long expected";
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        if (typeof message.isCompleted !== "boolean")
	                            return "isCompleted: boolean expected";
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        if (typeof message.isProcessing !== "boolean")
	                            return "isProcessing: boolean expected";
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        if (typeof message.isError !== "boolean")
	                            return "isError: boolean expected";
	                    if (message.logs != null && message.hasOwnProperty("logs")) {
	                        if (!Array.isArray(message.logs))
	                            return "logs: array expected";
	                        for (var i = 0; i < message.logs.length; ++i) {
	                            var error = $root.org.roylance.yadel.UILog.verify(message.logs[i]);
	                            if (error)
	                                return "logs." + error;
	                        }
	                    }
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        if (typeof message.isWaitingForAnotherDagTask !== "boolean")
	                            return "isWaitingForAnotherDagTask: boolean expected";
	                    return null;
	                };

	                /**
	                 * Creates a UINode message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UINode} UINode
	                 */
	                UINode.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UINode)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UINode();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.display != null)
	                        message.display = String(object.display);
	                    if (object.executionDate != null)
	                        if ($util.Long)
	                            (message.executionDate = $util.Long.fromValue(object.executionDate)).unsigned = false;
	                        else if (typeof object.executionDate === "string")
	                            message.executionDate = parseInt(object.executionDate, 10);
	                        else if (typeof object.executionDate === "number")
	                            message.executionDate = object.executionDate;
	                        else if (typeof object.executionDate === "object")
	                            message.executionDate = new $util.LongBits(object.executionDate.low >>> 0, object.executionDate.high >>> 0).toNumber();
	                    if (object.startDate != null)
	                        if ($util.Long)
	                            (message.startDate = $util.Long.fromValue(object.startDate)).unsigned = false;
	                        else if (typeof object.startDate === "string")
	                            message.startDate = parseInt(object.startDate, 10);
	                        else if (typeof object.startDate === "number")
	                            message.startDate = object.startDate;
	                        else if (typeof object.startDate === "object")
	                            message.startDate = new $util.LongBits(object.startDate.low >>> 0, object.startDate.high >>> 0).toNumber();
	                    if (object.endDate != null)
	                        if ($util.Long)
	                            (message.endDate = $util.Long.fromValue(object.endDate)).unsigned = false;
	                        else if (typeof object.endDate === "string")
	                            message.endDate = parseInt(object.endDate, 10);
	                        else if (typeof object.endDate === "number")
	                            message.endDate = object.endDate;
	                        else if (typeof object.endDate === "object")
	                            message.endDate = new $util.LongBits(object.endDate.low >>> 0, object.endDate.high >>> 0).toNumber();
	                    if (object.duration != null)
	                        if ($util.Long)
	                            (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
	                        else if (typeof object.duration === "string")
	                            message.duration = parseInt(object.duration, 10);
	                        else if (typeof object.duration === "number")
	                            message.duration = object.duration;
	                        else if (typeof object.duration === "object")
	                            message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
	                    if (object.isCompleted != null)
	                        message.isCompleted = Boolean(object.isCompleted);
	                    if (object.isProcessing != null)
	                        message.isProcessing = Boolean(object.isProcessing);
	                    if (object.isError != null)
	                        message.isError = Boolean(object.isError);
	                    if (object.logs) {
	                        if (!Array.isArray(object.logs))
	                            throw TypeError(".org.roylance.yadel.UINode.logs: array expected");
	                        message.logs = [];
	                        for (var i = 0; i < object.logs.length; ++i) {
	                            if (typeof object.logs[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.UINode.logs: object expected");
	                            message.logs[i] = $root.org.roylance.yadel.UILog.fromObject(object.logs[i]);
	                        }
	                    }
	                    if (object.isWaitingForAnotherDagTask != null)
	                        message.isWaitingForAnotherDagTask = Boolean(object.isWaitingForAnotherDagTask);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UINode message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UINode
	                 * @static
	                 * @param {org.roylance.yadel.UINode} message UINode
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UINode.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults)
	                        object.logs = [];
	                    if (options.defaults) {
	                        object.id = "";
	                        object.display = "";
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.executionDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.executionDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.startDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.startDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.endDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.endDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.duration = options.longs === String ? "0" : 0;
	                        object.isCompleted = false;
	                        object.isProcessing = false;
	                        object.isError = false;
	                        object.isWaitingForAnotherDagTask = false;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        object.display = message.display;
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (typeof message.executionDate === "number")
	                            object.executionDate = options.longs === String ? String(message.executionDate) : message.executionDate;
	                        else
	                            object.executionDate = options.longs === String ? $util.Long.prototype.toString.call(message.executionDate) : options.longs === Number ? new $util.LongBits(message.executionDate.low >>> 0, message.executionDate.high >>> 0).toNumber() : message.executionDate;
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (typeof message.startDate === "number")
	                            object.startDate = options.longs === String ? String(message.startDate) : message.startDate;
	                        else
	                            object.startDate = options.longs === String ? $util.Long.prototype.toString.call(message.startDate) : options.longs === Number ? new $util.LongBits(message.startDate.low >>> 0, message.startDate.high >>> 0).toNumber() : message.startDate;
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (typeof message.endDate === "number")
	                            object.endDate = options.longs === String ? String(message.endDate) : message.endDate;
	                        else
	                            object.endDate = options.longs === String ? $util.Long.prototype.toString.call(message.endDate) : options.longs === Number ? new $util.LongBits(message.endDate.low >>> 0, message.endDate.high >>> 0).toNumber() : message.endDate;
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (typeof message.duration === "number")
	                            object.duration = options.longs === String ? String(message.duration) : message.duration;
	                        else
	                            object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
	                    if (message.isCompleted != null && message.hasOwnProperty("isCompleted"))
	                        object.isCompleted = message.isCompleted;
	                    if (message.isProcessing != null && message.hasOwnProperty("isProcessing"))
	                        object.isProcessing = message.isProcessing;
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        object.isError = message.isError;
	                    if (message.logs && message.logs.length) {
	                        object.logs = [];
	                        for (var j = 0; j < message.logs.length; ++j)
	                            object.logs[j] = $root.org.roylance.yadel.UILog.toObject(message.logs[j], options);
	                    }
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        object.isWaitingForAnotherDagTask = message.isWaitingForAnotherDagTask;
	                    return object;
	                };

	                /**
	                 * Converts this UINode to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UINode
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UINode.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UINode;
	            })();

	            yadel.UILog = (function() {

	                /**
	                 * Properties of a UILog.
	                 * @memberof org.roylance.yadel
	                 * @interface IUILog
	                 * @property {string} [id] UILog id
	                 * @property {string} [message] UILog message
	                 */

	                /**
	                 * Constructs a new UILog.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UILog.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUILog=} [properties] Properties to set
	                 */
	                function UILog(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UILog id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.UILog
	                 * @instance
	                 */
	                UILog.prototype.id = "";

	                /**
	                 * UILog message.
	                 * @member {string}message
	                 * @memberof org.roylance.yadel.UILog
	                 * @instance
	                 */
	                UILog.prototype.message = "";

	                /**
	                 * Creates a new UILog instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {org.roylance.yadel.IUILog=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UILog} UILog instance
	                 */
	                UILog.create = function create(properties) {
	                    return new UILog(properties);
	                };

	                /**
	                 * Encodes the specified UILog message. Does not implicitly {@link org.roylance.yadel.UILog.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {org.roylance.yadel.IUILog} message UILog message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UILog.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UILog message, length delimited. Does not implicitly {@link org.roylance.yadel.UILog.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {org.roylance.yadel.IUILog} message UILog message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UILog.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UILog message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UILog} UILog
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UILog.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UILog();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.message = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UILog message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UILog} UILog
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UILog.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UILog message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UILog.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        if (!$util.isString(message.message))
	                            return "message: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a UILog message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UILog} UILog
	                 */
	                UILog.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UILog)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UILog();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.message != null)
	                        message.message = String(object.message);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UILog message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UILog
	                 * @static
	                 * @param {org.roylance.yadel.UILog} message UILog
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UILog.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.message = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        object.message = message.message;
	                    return object;
	                };

	                /**
	                 * Converts this UILog to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UILog
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UILog.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UILog;
	            })();

	            yadel.UIWorkerConfiguration = (function() {

	                /**
	                 * Properties of a UIWorkerConfiguration.
	                 * @memberof org.roylance.yadel
	                 * @interface IUIWorkerConfiguration
	                 * @property {string} [ip] UIWorkerConfiguration ip
	                 * @property {string} [port] UIWorkerConfiguration port
	                 * @property {string} [host] UIWorkerConfiguration host
	                 * @property {string} [initializedTime] UIWorkerConfiguration initializedTime
	                 * @property {org.roylance.yadel.UIWorkerState} [state] UIWorkerConfiguration state
	                 * @property {string} [taskDisplay] UIWorkerConfiguration taskDisplay
	                 * @property {string} [dagDisplay] UIWorkerConfiguration dagDisplay
	                 * @property {number|Long} [minutesBeforeTaskReset] UIWorkerConfiguration minutesBeforeTaskReset
	                 * @property {string} [taskStartTime] UIWorkerConfiguration taskStartTime
	                 * @property {string} [taskWorkingTimeDisplay] UIWorkerConfiguration taskWorkingTimeDisplay
	                 */

	                /**
	                 * Constructs a new UIWorkerConfiguration.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a UIWorkerConfiguration.
	                 * @constructor
	                 * @param {org.roylance.yadel.IUIWorkerConfiguration=} [properties] Properties to set
	                 */
	                function UIWorkerConfiguration(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * UIWorkerConfiguration ip.
	                 * @member {string}ip
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.ip = "";

	                /**
	                 * UIWorkerConfiguration port.
	                 * @member {string}port
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.port = "";

	                /**
	                 * UIWorkerConfiguration host.
	                 * @member {string}host
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.host = "";

	                /**
	                 * UIWorkerConfiguration initializedTime.
	                 * @member {string}initializedTime
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.initializedTime = "";

	                /**
	                 * UIWorkerConfiguration state.
	                 * @member {org.roylance.yadel.UIWorkerState}state
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.state = 0;

	                /**
	                 * UIWorkerConfiguration taskDisplay.
	                 * @member {string}taskDisplay
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.taskDisplay = "";

	                /**
	                 * UIWorkerConfiguration dagDisplay.
	                 * @member {string}dagDisplay
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.dagDisplay = "";

	                /**
	                 * UIWorkerConfiguration minutesBeforeTaskReset.
	                 * @member {number|Long}minutesBeforeTaskReset
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.minutesBeforeTaskReset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

	                /**
	                 * UIWorkerConfiguration taskStartTime.
	                 * @member {string}taskStartTime
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.taskStartTime = "";

	                /**
	                 * UIWorkerConfiguration taskWorkingTimeDisplay.
	                 * @member {string}taskWorkingTimeDisplay
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 */
	                UIWorkerConfiguration.prototype.taskWorkingTimeDisplay = "";

	                /**
	                 * Creates a new UIWorkerConfiguration instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IUIWorkerConfiguration=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.UIWorkerConfiguration} UIWorkerConfiguration instance
	                 */
	                UIWorkerConfiguration.create = function create(properties) {
	                    return new UIWorkerConfiguration(properties);
	                };

	                /**
	                 * Encodes the specified UIWorkerConfiguration message. Does not implicitly {@link org.roylance.yadel.UIWorkerConfiguration.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IUIWorkerConfiguration} message UIWorkerConfiguration message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIWorkerConfiguration.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ip);
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.port);
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.host);
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.initializedTime);
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.state);
	                    if (message.taskDisplay != null && message.hasOwnProperty("taskDisplay"))
	                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.taskDisplay);
	                    if (message.dagDisplay != null && message.hasOwnProperty("dagDisplay"))
	                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.dagDisplay);
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.minutesBeforeTaskReset);
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.taskStartTime);
	                    if (message.taskWorkingTimeDisplay != null && message.hasOwnProperty("taskWorkingTimeDisplay"))
	                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.taskWorkingTimeDisplay);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified UIWorkerConfiguration message, length delimited. Does not implicitly {@link org.roylance.yadel.UIWorkerConfiguration.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IUIWorkerConfiguration} message UIWorkerConfiguration message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                UIWorkerConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a UIWorkerConfiguration message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.UIWorkerConfiguration} UIWorkerConfiguration
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIWorkerConfiguration.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.UIWorkerConfiguration();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.ip = reader.string();
	                            break;
	                        case 2:
	                            message.port = reader.string();
	                            break;
	                        case 3:
	                            message.host = reader.string();
	                            break;
	                        case 4:
	                            message.initializedTime = reader.string();
	                            break;
	                        case 5:
	                            message.state = reader.int32();
	                            break;
	                        case 6:
	                            message.taskDisplay = reader.string();
	                            break;
	                        case 7:
	                            message.dagDisplay = reader.string();
	                            break;
	                        case 8:
	                            message.minutesBeforeTaskReset = reader.uint64();
	                            break;
	                        case 9:
	                            message.taskStartTime = reader.string();
	                            break;
	                        case 10:
	                            message.taskWorkingTimeDisplay = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a UIWorkerConfiguration message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.UIWorkerConfiguration} UIWorkerConfiguration
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                UIWorkerConfiguration.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a UIWorkerConfiguration message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                UIWorkerConfiguration.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        if (!$util.isString(message.ip))
	                            return "ip: string expected";
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        if (!$util.isString(message.port))
	                            return "port: string expected";
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        if (!$util.isString(message.host))
	                            return "host: string expected";
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        if (!$util.isString(message.initializedTime))
	                            return "initializedTime: string expected";
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        switch (message.state) {
	                        default:
	                            return "state: enum value expected";
	                        case 0:
	                        case 1:
	                            break;
	                        }
	                    if (message.taskDisplay != null && message.hasOwnProperty("taskDisplay"))
	                        if (!$util.isString(message.taskDisplay))
	                            return "taskDisplay: string expected";
	                    if (message.dagDisplay != null && message.hasOwnProperty("dagDisplay"))
	                        if (!$util.isString(message.dagDisplay))
	                            return "dagDisplay: string expected";
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        if (!$util.isInteger(message.minutesBeforeTaskReset) && !(message.minutesBeforeTaskReset && $util.isInteger(message.minutesBeforeTaskReset.low) && $util.isInteger(message.minutesBeforeTaskReset.high)))
	                            return "minutesBeforeTaskReset: integer|Long expected";
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        if (!$util.isString(message.taskStartTime))
	                            return "taskStartTime: string expected";
	                    if (message.taskWorkingTimeDisplay != null && message.hasOwnProperty("taskWorkingTimeDisplay"))
	                        if (!$util.isString(message.taskWorkingTimeDisplay))
	                            return "taskWorkingTimeDisplay: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a UIWorkerConfiguration message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.UIWorkerConfiguration} UIWorkerConfiguration
	                 */
	                UIWorkerConfiguration.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.UIWorkerConfiguration)
	                        return object;
	                    var message = new $root.org.roylance.yadel.UIWorkerConfiguration();
	                    if (object.ip != null)
	                        message.ip = String(object.ip);
	                    if (object.port != null)
	                        message.port = String(object.port);
	                    if (object.host != null)
	                        message.host = String(object.host);
	                    if (object.initializedTime != null)
	                        message.initializedTime = String(object.initializedTime);
	                    switch (object.state) {
	                    case "CURRENTLY_WORKING":
	                    case 0:
	                        message.state = 0;
	                        break;
	                    case "CURRENTLY_IDLE":
	                    case 1:
	                        message.state = 1;
	                        break;
	                    }
	                    if (object.taskDisplay != null)
	                        message.taskDisplay = String(object.taskDisplay);
	                    if (object.dagDisplay != null)
	                        message.dagDisplay = String(object.dagDisplay);
	                    if (object.minutesBeforeTaskReset != null)
	                        if ($util.Long)
	                            (message.minutesBeforeTaskReset = $util.Long.fromValue(object.minutesBeforeTaskReset)).unsigned = true;
	                        else if (typeof object.minutesBeforeTaskReset === "string")
	                            message.minutesBeforeTaskReset = parseInt(object.minutesBeforeTaskReset, 10);
	                        else if (typeof object.minutesBeforeTaskReset === "number")
	                            message.minutesBeforeTaskReset = object.minutesBeforeTaskReset;
	                        else if (typeof object.minutesBeforeTaskReset === "object")
	                            message.minutesBeforeTaskReset = new $util.LongBits(object.minutesBeforeTaskReset.low >>> 0, object.minutesBeforeTaskReset.high >>> 0).toNumber(true);
	                    if (object.taskStartTime != null)
	                        message.taskStartTime = String(object.taskStartTime);
	                    if (object.taskWorkingTimeDisplay != null)
	                        message.taskWorkingTimeDisplay = String(object.taskWorkingTimeDisplay);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a UIWorkerConfiguration message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.UIWorkerConfiguration} message UIWorkerConfiguration
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                UIWorkerConfiguration.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.ip = "";
	                        object.port = "";
	                        object.host = "";
	                        object.initializedTime = "";
	                        object.state = options.enums === String ? "CURRENTLY_WORKING" : 0;
	                        object.taskDisplay = "";
	                        object.dagDisplay = "";
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, true);
	                            object.minutesBeforeTaskReset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.minutesBeforeTaskReset = options.longs === String ? "0" : 0;
	                        object.taskStartTime = "";
	                        object.taskWorkingTimeDisplay = "";
	                    }
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        object.ip = message.ip;
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        object.port = message.port;
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        object.host = message.host;
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        object.initializedTime = message.initializedTime;
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        object.state = options.enums === String ? $root.org.roylance.yadel.UIWorkerState[message.state] : message.state;
	                    if (message.taskDisplay != null && message.hasOwnProperty("taskDisplay"))
	                        object.taskDisplay = message.taskDisplay;
	                    if (message.dagDisplay != null && message.hasOwnProperty("dagDisplay"))
	                        object.dagDisplay = message.dagDisplay;
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        if (typeof message.minutesBeforeTaskReset === "number")
	                            object.minutesBeforeTaskReset = options.longs === String ? String(message.minutesBeforeTaskReset) : message.minutesBeforeTaskReset;
	                        else
	                            object.minutesBeforeTaskReset = options.longs === String ? $util.Long.prototype.toString.call(message.minutesBeforeTaskReset) : options.longs === Number ? new $util.LongBits(message.minutesBeforeTaskReset.low >>> 0, message.minutesBeforeTaskReset.high >>> 0).toNumber(true) : message.minutesBeforeTaskReset;
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        object.taskStartTime = message.taskStartTime;
	                    if (message.taskWorkingTimeDisplay != null && message.hasOwnProperty("taskWorkingTimeDisplay"))
	                        object.taskWorkingTimeDisplay = message.taskWorkingTimeDisplay;
	                    return object;
	                };

	                /**
	                 * Converts this UIWorkerConfiguration to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.UIWorkerConfiguration
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                UIWorkerConfiguration.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return UIWorkerConfiguration;
	            })();

	            /**
	             * UIWorkerState enum.
	             * @enum {string}
	             * @property {number} CURRENTLY_WORKING=0 CURRENTLY_WORKING value
	             * @property {number} CURRENTLY_IDLE=1 CURRENTLY_IDLE value
	             */
	            yadel.UIWorkerState = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "CURRENTLY_WORKING"] = 0;
	                values[valuesById[1] = "CURRENTLY_IDLE"] = 1;
	                return values;
	            })();

	            /**
	             * OSBitVersion enum.
	             * @enum {string}
	             * @property {number} V_64_BIT_VERSION=0 V_64_BIT_VERSION value
	             * @property {number} V_32_BIT_VERSION=1 V_32_BIT_VERSION value
	             */
	            yadel.OSBitVersion = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "V_64_BIT_VERSION"] = 0;
	                values[valuesById[1] = "V_32_BIT_VERSION"] = 1;
	                return values;
	            })();

	            /**
	             * OSTypeVersion enum.
	             * @enum {string}
	             * @property {number} MAC_OS_TYPE_VERSION=0 MAC_OS_TYPE_VERSION value
	             * @property {number} WIN_OS_TYPE_VERSION=1 WIN_OS_TYPE_VERSION value
	             * @property {number} UBUNTU_OS_TYPE_VERSION=2 UBUNTU_OS_TYPE_VERSION value
	             * @property {number} CENTOS_OS_TYPE_VERSION=3 CENTOS_OS_TYPE_VERSION value
	             * @property {number} FEDORA_OS_TYPE_VERSION=4 FEDORA_OS_TYPE_VERSION value
	             * @property {number} REDHAT_OS_TYPE_VERSION=5 REDHAT_OS_TYPE_VERSION value
	             * @property {number} LINUX_OS_TYPE_VERSION=6 LINUX_OS_TYPE_VERSION value
	             */
	            yadel.OSTypeVersion = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "MAC_OS_TYPE_VERSION"] = 0;
	                values[valuesById[1] = "WIN_OS_TYPE_VERSION"] = 1;
	                values[valuesById[2] = "UBUNTU_OS_TYPE_VERSION"] = 2;
	                values[valuesById[3] = "CENTOS_OS_TYPE_VERSION"] = 3;
	                values[valuesById[4] = "FEDORA_OS_TYPE_VERSION"] = 4;
	                values[valuesById[5] = "REDHAT_OS_TYPE_VERSION"] = 5;
	                values[valuesById[6] = "LINUX_OS_TYPE_VERSION"] = 6;
	                return values;
	            })();

	            /**
	             * WorkerState enum.
	             * @enum {string}
	             * @property {number} WORKING=0 WORKING value
	             * @property {number} IDLE=1 IDLE value
	             */
	            yadel.WorkerState = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "WORKING"] = 0;
	                values[valuesById[1] = "IDLE"] = 1;
	                return values;
	            })();

	            /**
	             * WorkerToManagerMessageType enum.
	             * @enum {string}
	             * @property {number} REGISTRATION=0 REGISTRATION value
	             */
	            yadel.WorkerToManagerMessageType = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "REGISTRATION"] = 0;
	                return values;
	            })();

	            /**
	             * ManagerToManagerMessageType enum.
	             * @enum {string}
	             * @property {number} ENSURE_WORKERS_WORKING=0 ENSURE_WORKERS_WORKING value
	             */
	            yadel.ManagerToManagerMessageType = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "ENSURE_WORKERS_WORKING"] = 0;
	                return values;
	            })();

	            /**
	             * ActorRole enum.
	             * @enum {string}
	             * @property {number} MANAGER=0 MANAGER value
	             * @property {number} WORKER=1 WORKER value
	             */
	            yadel.ActorRole = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "MANAGER"] = 0;
	                values[valuesById[1] = "WORKER"] = 1;
	                return values;
	            })();

	            /**
	             * WorkerOperationsComparison enum.
	             * @enum {string}
	             * @property {number} EQUALS_OPERATION=0 EQUALS_OPERATION value
	             * @property {number} NOT_EQUALS_OPERATION=1 NOT_EQUALS_OPERATION value
	             * @property {number} GREATER_THAN_OPERATION=2 GREATER_THAN_OPERATION value
	             * @property {number} LESS_THAN_OPERATION=3 LESS_THAN_OPERATION value
	             * @property {number} GREATER_THAN_OR_EQUALS_OPERATION=4 GREATER_THAN_OR_EQUALS_OPERATION value
	             * @property {number} LESS_THAN_OR_EQUALS_OPERATION=5 LESS_THAN_OR_EQUALS_OPERATION value
	             * @property {number} CONTAINS_OPERATION=6 CONTAINS_OPERATION value
	             * @property {number} MATCHES_OPERATION=7 MATCHES_OPERATION value
	             */
	            yadel.WorkerOperationsComparison = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "EQUALS_OPERATION"] = 0;
	                values[valuesById[1] = "NOT_EQUALS_OPERATION"] = 1;
	                values[valuesById[2] = "GREATER_THAN_OPERATION"] = 2;
	                values[valuesById[3] = "LESS_THAN_OPERATION"] = 3;
	                values[valuesById[4] = "GREATER_THAN_OR_EQUALS_OPERATION"] = 4;
	                values[valuesById[5] = "LESS_THAN_OR_EQUALS_OPERATION"] = 5;
	                values[valuesById[6] = "CONTAINS_OPERATION"] = 6;
	                values[valuesById[7] = "MATCHES_OPERATION"] = 7;
	                return values;
	            })();

	            /**
	             * WorkerConnection enum.
	             * @enum {string}
	             * @property {number} NONE=0 NONE value
	             * @property {number} AND=1 AND value
	             * @property {number} OR=2 OR value
	             */
	            yadel.WorkerConnection = (function() {
	                var valuesById = {}, values = Object.create(valuesById);
	                values[valuesById[0] = "NONE"] = 0;
	                values[valuesById[1] = "AND"] = 1;
	                values[valuesById[2] = "OR"] = 2;
	                return values;
	            })();

	            yadel.WorkerProperty = (function() {

	                /**
	                 * Properties of a WorkerProperty.
	                 * @memberof org.roylance.yadel
	                 * @interface IWorkerProperty
	                 * @property {string} [id] WorkerProperty id
	                 * @property {string} [key] WorkerProperty key
	                 * @property {string} [value] WorkerProperty value
	                 * @property {number} [numberValue] WorkerProperty numberValue
	                 * @property {org.roylance.yadel.OSBitVersion} [osBitVersion] WorkerProperty osBitVersion
	                 * @property {org.roylance.yadel.OSTypeVersion} [osTypeVersion] WorkerProperty osTypeVersion
	                 */

	                /**
	                 * Constructs a new WorkerProperty.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a WorkerProperty.
	                 * @constructor
	                 * @param {org.roylance.yadel.IWorkerProperty=} [properties] Properties to set
	                 */
	                function WorkerProperty(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * WorkerProperty id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.id = "";

	                /**
	                 * WorkerProperty key.
	                 * @member {string}key
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.key = "";

	                /**
	                 * WorkerProperty value.
	                 * @member {string}value
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.value = "";

	                /**
	                 * WorkerProperty numberValue.
	                 * @member {number}numberValue
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.numberValue = 0;

	                /**
	                 * WorkerProperty osBitVersion.
	                 * @member {org.roylance.yadel.OSBitVersion}osBitVersion
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.osBitVersion = 0;

	                /**
	                 * WorkerProperty osTypeVersion.
	                 * @member {org.roylance.yadel.OSTypeVersion}osTypeVersion
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 */
	                WorkerProperty.prototype.osTypeVersion = 0;

	                /**
	                 * Creates a new WorkerProperty instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperty=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.WorkerProperty} WorkerProperty instance
	                 */
	                WorkerProperty.create = function create(properties) {
	                    return new WorkerProperty(properties);
	                };

	                /**
	                 * Encodes the specified WorkerProperty message. Does not implicitly {@link org.roylance.yadel.WorkerProperty.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperty} message WorkerProperty message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerProperty.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.key != null && message.hasOwnProperty("key"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
	                    if (message.value != null && message.hasOwnProperty("value"))
	                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
	                    if (message.numberValue != null && message.hasOwnProperty("numberValue"))
	                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.numberValue);
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.osBitVersion);
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.osTypeVersion);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified WorkerProperty message, length delimited. Does not implicitly {@link org.roylance.yadel.WorkerProperty.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperty} message WorkerProperty message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerProperty.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a WorkerProperty message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.WorkerProperty} WorkerProperty
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerProperty.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.WorkerProperty();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.key = reader.string();
	                            break;
	                        case 3:
	                            message.value = reader.string();
	                            break;
	                        case 4:
	                            message.numberValue = reader.double();
	                            break;
	                        case 5:
	                            message.osBitVersion = reader.int32();
	                            break;
	                        case 6:
	                            message.osTypeVersion = reader.int32();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a WorkerProperty message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.WorkerProperty} WorkerProperty
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerProperty.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a WorkerProperty message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                WorkerProperty.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.key != null && message.hasOwnProperty("key"))
	                        if (!$util.isString(message.key))
	                            return "key: string expected";
	                    if (message.value != null && message.hasOwnProperty("value"))
	                        if (!$util.isString(message.value))
	                            return "value: string expected";
	                    if (message.numberValue != null && message.hasOwnProperty("numberValue"))
	                        if (typeof message.numberValue !== "number")
	                            return "numberValue: number expected";
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        switch (message.osBitVersion) {
	                        default:
	                            return "osBitVersion: enum value expected";
	                        case 0:
	                        case 1:
	                            break;
	                        }
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        switch (message.osTypeVersion) {
	                        default:
	                            return "osTypeVersion: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                            break;
	                        }
	                    return null;
	                };

	                /**
	                 * Creates a WorkerProperty message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.WorkerProperty} WorkerProperty
	                 */
	                WorkerProperty.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.WorkerProperty)
	                        return object;
	                    var message = new $root.org.roylance.yadel.WorkerProperty();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.key != null)
	                        message.key = String(object.key);
	                    if (object.value != null)
	                        message.value = String(object.value);
	                    if (object.numberValue != null)
	                        message.numberValue = Number(object.numberValue);
	                    switch (object.osBitVersion) {
	                    case "V_64_BIT_VERSION":
	                    case 0:
	                        message.osBitVersion = 0;
	                        break;
	                    case "V_32_BIT_VERSION":
	                    case 1:
	                        message.osBitVersion = 1;
	                        break;
	                    }
	                    switch (object.osTypeVersion) {
	                    case "MAC_OS_TYPE_VERSION":
	                    case 0:
	                        message.osTypeVersion = 0;
	                        break;
	                    case "WIN_OS_TYPE_VERSION":
	                    case 1:
	                        message.osTypeVersion = 1;
	                        break;
	                    case "UBUNTU_OS_TYPE_VERSION":
	                    case 2:
	                        message.osTypeVersion = 2;
	                        break;
	                    case "CENTOS_OS_TYPE_VERSION":
	                    case 3:
	                        message.osTypeVersion = 3;
	                        break;
	                    case "FEDORA_OS_TYPE_VERSION":
	                    case 4:
	                        message.osTypeVersion = 4;
	                        break;
	                    case "REDHAT_OS_TYPE_VERSION":
	                    case 5:
	                        message.osTypeVersion = 5;
	                        break;
	                    case "LINUX_OS_TYPE_VERSION":
	                    case 6:
	                        message.osTypeVersion = 6;
	                        break;
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a WorkerProperty message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @static
	                 * @param {org.roylance.yadel.WorkerProperty} message WorkerProperty
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                WorkerProperty.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.key = "";
	                        object.value = "";
	                        object.numberValue = 0;
	                        object.osBitVersion = options.enums === String ? "V_64_BIT_VERSION" : 0;
	                        object.osTypeVersion = options.enums === String ? "MAC_OS_TYPE_VERSION" : 0;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.key != null && message.hasOwnProperty("key"))
	                        object.key = message.key;
	                    if (message.value != null && message.hasOwnProperty("value"))
	                        object.value = message.value;
	                    if (message.numberValue != null && message.hasOwnProperty("numberValue"))
	                        object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        object.osBitVersion = options.enums === String ? $root.org.roylance.yadel.OSBitVersion[message.osBitVersion] : message.osBitVersion;
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        object.osTypeVersion = options.enums === String ? $root.org.roylance.yadel.OSTypeVersion[message.osTypeVersion] : message.osTypeVersion;
	                    return object;
	                };

	                /**
	                 * Converts this WorkerProperty to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.WorkerProperty
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                WorkerProperty.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return WorkerProperty;
	            })();

	            yadel.WorkerFilter = (function() {

	                /**
	                 * Properties of a WorkerFilter.
	                 * @memberof org.roylance.yadel
	                 * @interface IWorkerFilter
	                 * @property {string} [id] WorkerFilter id
	                 * @property {org.roylance.yadel.IWorkerProperty} [firstProperty] WorkerFilter firstProperty
	                 * @property {org.roylance.yadel.IWorkerFilter} [firstComparison] WorkerFilter firstComparison
	                 * @property {org.roylance.yadel.IWorkerProperty} [secondProperty] WorkerFilter secondProperty
	                 * @property {org.roylance.yadel.IWorkerFilter} [secondComparison] WorkerFilter secondComparison
	                 * @property {org.roylance.yadel.WorkerOperationsComparison} [operation] WorkerFilter operation
	                 * @property {org.roylance.yadel.WorkerConnection} [connection] WorkerFilter connection
	                 * @property {org.roylance.yadel.WorkerOperationsComparison} [firstOperator] WorkerFilter firstOperator
	                 * @property {org.roylance.yadel.WorkerOperationsComparison} [secondOperator] WorkerFilter secondOperator
	                 */

	                /**
	                 * Constructs a new WorkerFilter.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a WorkerFilter.
	                 * @constructor
	                 * @param {org.roylance.yadel.IWorkerFilter=} [properties] Properties to set
	                 */
	                function WorkerFilter(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * WorkerFilter id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.id = "";

	                /**
	                 * WorkerFilter firstProperty.
	                 * @member {(org.roylance.yadel.IWorkerProperty|null|undefined)}firstProperty
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.firstProperty = null;

	                /**
	                 * WorkerFilter firstComparison.
	                 * @member {(org.roylance.yadel.IWorkerFilter|null|undefined)}firstComparison
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.firstComparison = null;

	                /**
	                 * WorkerFilter secondProperty.
	                 * @member {(org.roylance.yadel.IWorkerProperty|null|undefined)}secondProperty
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.secondProperty = null;

	                /**
	                 * WorkerFilter secondComparison.
	                 * @member {(org.roylance.yadel.IWorkerFilter|null|undefined)}secondComparison
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.secondComparison = null;

	                /**
	                 * WorkerFilter operation.
	                 * @member {org.roylance.yadel.WorkerOperationsComparison}operation
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.operation = 0;

	                /**
	                 * WorkerFilter connection.
	                 * @member {org.roylance.yadel.WorkerConnection}connection
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.connection = 0;

	                /**
	                 * WorkerFilter firstOperator.
	                 * @member {org.roylance.yadel.WorkerOperationsComparison}firstOperator
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.firstOperator = 0;

	                /**
	                 * WorkerFilter secondOperator.
	                 * @member {org.roylance.yadel.WorkerOperationsComparison}secondOperator
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 */
	                WorkerFilter.prototype.secondOperator = 0;

	                /**
	                 * Creates a new WorkerFilter instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerFilter=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.WorkerFilter} WorkerFilter instance
	                 */
	                WorkerFilter.create = function create(properties) {
	                    return new WorkerFilter(properties);
	                };

	                /**
	                 * Encodes the specified WorkerFilter message. Does not implicitly {@link org.roylance.yadel.WorkerFilter.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerFilter} message WorkerFilter message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerFilter.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.firstProperty != null && message.hasOwnProperty("firstProperty"))
	                        $root.org.roylance.yadel.WorkerProperty.encode(message.firstProperty, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.firstComparison != null && message.hasOwnProperty("firstComparison"))
	                        $root.org.roylance.yadel.WorkerFilter.encode(message.firstComparison, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.secondProperty != null && message.hasOwnProperty("secondProperty"))
	                        $root.org.roylance.yadel.WorkerProperty.encode(message.secondProperty, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
	                    if (message.secondComparison != null && message.hasOwnProperty("secondComparison"))
	                        $root.org.roylance.yadel.WorkerFilter.encode(message.secondComparison, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
	                    if (message.operation != null && message.hasOwnProperty("operation"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.operation);
	                    if (message.connection != null && message.hasOwnProperty("connection"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.connection);
	                    if (message.firstOperator != null && message.hasOwnProperty("firstOperator"))
	                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.firstOperator);
	                    if (message.secondOperator != null && message.hasOwnProperty("secondOperator"))
	                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.secondOperator);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified WorkerFilter message, length delimited. Does not implicitly {@link org.roylance.yadel.WorkerFilter.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerFilter} message WorkerFilter message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerFilter.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a WorkerFilter message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.WorkerFilter} WorkerFilter
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerFilter.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.WorkerFilter();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.firstProperty = $root.org.roylance.yadel.WorkerProperty.decode(reader, reader.uint32());
	                            break;
	                        case 3:
	                            message.firstComparison = $root.org.roylance.yadel.WorkerFilter.decode(reader, reader.uint32());
	                            break;
	                        case 4:
	                            message.secondProperty = $root.org.roylance.yadel.WorkerProperty.decode(reader, reader.uint32());
	                            break;
	                        case 5:
	                            message.secondComparison = $root.org.roylance.yadel.WorkerFilter.decode(reader, reader.uint32());
	                            break;
	                        case 6:
	                            message.operation = reader.int32();
	                            break;
	                        case 7:
	                            message.connection = reader.int32();
	                            break;
	                        case 8:
	                            message.firstOperator = reader.int32();
	                            break;
	                        case 9:
	                            message.secondOperator = reader.int32();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a WorkerFilter message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.WorkerFilter} WorkerFilter
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerFilter.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a WorkerFilter message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                WorkerFilter.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.firstProperty != null && message.hasOwnProperty("firstProperty")) {
	                        var error = $root.org.roylance.yadel.WorkerProperty.verify(message.firstProperty);
	                        if (error)
	                            return "firstProperty." + error;
	                    }
	                    if (message.firstComparison != null && message.hasOwnProperty("firstComparison")) {
	                        error = $root.org.roylance.yadel.WorkerFilter.verify(message.firstComparison);
	                        if (error)
	                            return "firstComparison." + error;
	                    }
	                    if (message.secondProperty != null && message.hasOwnProperty("secondProperty")) {
	                        error = $root.org.roylance.yadel.WorkerProperty.verify(message.secondProperty);
	                        if (error)
	                            return "secondProperty." + error;
	                    }
	                    if (message.secondComparison != null && message.hasOwnProperty("secondComparison")) {
	                        error = $root.org.roylance.yadel.WorkerFilter.verify(message.secondComparison);
	                        if (error)
	                            return "secondComparison." + error;
	                    }
	                    if (message.operation != null && message.hasOwnProperty("operation"))
	                        switch (message.operation) {
	                        default:
	                            return "operation: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                        case 7:
	                            break;
	                        }
	                    if (message.connection != null && message.hasOwnProperty("connection"))
	                        switch (message.connection) {
	                        default:
	                            return "connection: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                            break;
	                        }
	                    if (message.firstOperator != null && message.hasOwnProperty("firstOperator"))
	                        switch (message.firstOperator) {
	                        default:
	                            return "firstOperator: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                        case 7:
	                            break;
	                        }
	                    if (message.secondOperator != null && message.hasOwnProperty("secondOperator"))
	                        switch (message.secondOperator) {
	                        default:
	                            return "secondOperator: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                        case 7:
	                            break;
	                        }
	                    return null;
	                };

	                /**
	                 * Creates a WorkerFilter message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.WorkerFilter} WorkerFilter
	                 */
	                WorkerFilter.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.WorkerFilter)
	                        return object;
	                    var message = new $root.org.roylance.yadel.WorkerFilter();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.firstProperty != null) {
	                        if (typeof object.firstProperty !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerFilter.firstProperty: object expected");
	                        message.firstProperty = $root.org.roylance.yadel.WorkerProperty.fromObject(object.firstProperty);
	                    }
	                    if (object.firstComparison != null) {
	                        if (typeof object.firstComparison !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerFilter.firstComparison: object expected");
	                        message.firstComparison = $root.org.roylance.yadel.WorkerFilter.fromObject(object.firstComparison);
	                    }
	                    if (object.secondProperty != null) {
	                        if (typeof object.secondProperty !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerFilter.secondProperty: object expected");
	                        message.secondProperty = $root.org.roylance.yadel.WorkerProperty.fromObject(object.secondProperty);
	                    }
	                    if (object.secondComparison != null) {
	                        if (typeof object.secondComparison !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerFilter.secondComparison: object expected");
	                        message.secondComparison = $root.org.roylance.yadel.WorkerFilter.fromObject(object.secondComparison);
	                    }
	                    switch (object.operation) {
	                    case "EQUALS_OPERATION":
	                    case 0:
	                        message.operation = 0;
	                        break;
	                    case "NOT_EQUALS_OPERATION":
	                    case 1:
	                        message.operation = 1;
	                        break;
	                    case "GREATER_THAN_OPERATION":
	                    case 2:
	                        message.operation = 2;
	                        break;
	                    case "LESS_THAN_OPERATION":
	                    case 3:
	                        message.operation = 3;
	                        break;
	                    case "GREATER_THAN_OR_EQUALS_OPERATION":
	                    case 4:
	                        message.operation = 4;
	                        break;
	                    case "LESS_THAN_OR_EQUALS_OPERATION":
	                    case 5:
	                        message.operation = 5;
	                        break;
	                    case "CONTAINS_OPERATION":
	                    case 6:
	                        message.operation = 6;
	                        break;
	                    case "MATCHES_OPERATION":
	                    case 7:
	                        message.operation = 7;
	                        break;
	                    }
	                    switch (object.connection) {
	                    case "NONE":
	                    case 0:
	                        message.connection = 0;
	                        break;
	                    case "AND":
	                    case 1:
	                        message.connection = 1;
	                        break;
	                    case "OR":
	                    case 2:
	                        message.connection = 2;
	                        break;
	                    }
	                    switch (object.firstOperator) {
	                    case "EQUALS_OPERATION":
	                    case 0:
	                        message.firstOperator = 0;
	                        break;
	                    case "NOT_EQUALS_OPERATION":
	                    case 1:
	                        message.firstOperator = 1;
	                        break;
	                    case "GREATER_THAN_OPERATION":
	                    case 2:
	                        message.firstOperator = 2;
	                        break;
	                    case "LESS_THAN_OPERATION":
	                    case 3:
	                        message.firstOperator = 3;
	                        break;
	                    case "GREATER_THAN_OR_EQUALS_OPERATION":
	                    case 4:
	                        message.firstOperator = 4;
	                        break;
	                    case "LESS_THAN_OR_EQUALS_OPERATION":
	                    case 5:
	                        message.firstOperator = 5;
	                        break;
	                    case "CONTAINS_OPERATION":
	                    case 6:
	                        message.firstOperator = 6;
	                        break;
	                    case "MATCHES_OPERATION":
	                    case 7:
	                        message.firstOperator = 7;
	                        break;
	                    }
	                    switch (object.secondOperator) {
	                    case "EQUALS_OPERATION":
	                    case 0:
	                        message.secondOperator = 0;
	                        break;
	                    case "NOT_EQUALS_OPERATION":
	                    case 1:
	                        message.secondOperator = 1;
	                        break;
	                    case "GREATER_THAN_OPERATION":
	                    case 2:
	                        message.secondOperator = 2;
	                        break;
	                    case "LESS_THAN_OPERATION":
	                    case 3:
	                        message.secondOperator = 3;
	                        break;
	                    case "GREATER_THAN_OR_EQUALS_OPERATION":
	                    case 4:
	                        message.secondOperator = 4;
	                        break;
	                    case "LESS_THAN_OR_EQUALS_OPERATION":
	                    case 5:
	                        message.secondOperator = 5;
	                        break;
	                    case "CONTAINS_OPERATION":
	                    case 6:
	                        message.secondOperator = 6;
	                        break;
	                    case "MATCHES_OPERATION":
	                    case 7:
	                        message.secondOperator = 7;
	                        break;
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a WorkerFilter message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @static
	                 * @param {org.roylance.yadel.WorkerFilter} message WorkerFilter
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                WorkerFilter.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.firstProperty = null;
	                        object.firstComparison = null;
	                        object.secondProperty = null;
	                        object.secondComparison = null;
	                        object.operation = options.enums === String ? "EQUALS_OPERATION" : 0;
	                        object.connection = options.enums === String ? "NONE" : 0;
	                        object.firstOperator = options.enums === String ? "EQUALS_OPERATION" : 0;
	                        object.secondOperator = options.enums === String ? "EQUALS_OPERATION" : 0;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.firstProperty != null && message.hasOwnProperty("firstProperty"))
	                        object.firstProperty = $root.org.roylance.yadel.WorkerProperty.toObject(message.firstProperty, options);
	                    if (message.firstComparison != null && message.hasOwnProperty("firstComparison"))
	                        object.firstComparison = $root.org.roylance.yadel.WorkerFilter.toObject(message.firstComparison, options);
	                    if (message.secondProperty != null && message.hasOwnProperty("secondProperty"))
	                        object.secondProperty = $root.org.roylance.yadel.WorkerProperty.toObject(message.secondProperty, options);
	                    if (message.secondComparison != null && message.hasOwnProperty("secondComparison"))
	                        object.secondComparison = $root.org.roylance.yadel.WorkerFilter.toObject(message.secondComparison, options);
	                    if (message.operation != null && message.hasOwnProperty("operation"))
	                        object.operation = options.enums === String ? $root.org.roylance.yadel.WorkerOperationsComparison[message.operation] : message.operation;
	                    if (message.connection != null && message.hasOwnProperty("connection"))
	                        object.connection = options.enums === String ? $root.org.roylance.yadel.WorkerConnection[message.connection] : message.connection;
	                    if (message.firstOperator != null && message.hasOwnProperty("firstOperator"))
	                        object.firstOperator = options.enums === String ? $root.org.roylance.yadel.WorkerOperationsComparison[message.firstOperator] : message.firstOperator;
	                    if (message.secondOperator != null && message.hasOwnProperty("secondOperator"))
	                        object.secondOperator = options.enums === String ? $root.org.roylance.yadel.WorkerOperationsComparison[message.secondOperator] : message.secondOperator;
	                    return object;
	                };

	                /**
	                 * Converts this WorkerFilter to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.WorkerFilter
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                WorkerFilter.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return WorkerFilter;
	            })();

	            yadel.WorkerConfiguration = (function() {

	                /**
	                 * Properties of a WorkerConfiguration.
	                 * @memberof org.roylance.yadel
	                 * @interface IWorkerConfiguration
	                 * @property {string} [id] WorkerConfiguration id
	                 * @property {string} [ip] WorkerConfiguration ip
	                 * @property {string} [port] WorkerConfiguration port
	                 * @property {string} [host] WorkerConfiguration host
	                 * @property {string} [initializedTime] WorkerConfiguration initializedTime
	                 * @property {org.roylance.yadel.WorkerState} [state] WorkerConfiguration state
	                 * @property {org.roylance.yadel.ITask} [task] WorkerConfiguration task
	                 * @property {org.roylance.yadel.IDag} [dag] WorkerConfiguration dag
	                 * @property {number|Long} [minutesBeforeTaskReset] WorkerConfiguration minutesBeforeTaskReset
	                 * @property {string} [taskStartTime] WorkerConfiguration taskStartTime
	                 * @property {org.roylance.yadel.OSBitVersion} [osBitVersion] WorkerConfiguration osBitVersion
	                 * @property {org.roylance.yadel.OSTypeVersion} [osTypeVersion] WorkerConfiguration osTypeVersion
	                 * @property {string} [osMajorVersion] WorkerConfiguration osMajorVersion
	                 * @property {string} [osMinorVersion] WorkerConfiguration osMinorVersion
	                 * @property {string} [osBuildVersion] WorkerConfiguration osBuildVersion
	                 * @property {Array.<org.roylance.yadel.IWorkerProperty>} [properties] WorkerConfiguration properties
	                 */

	                /**
	                 * Constructs a new WorkerConfiguration.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a WorkerConfiguration.
	                 * @constructor
	                 * @param {org.roylance.yadel.IWorkerConfiguration=} [properties] Properties to set
	                 */
	                function WorkerConfiguration(properties) {
	                    this.properties = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * WorkerConfiguration id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.id = "";

	                /**
	                 * WorkerConfiguration ip.
	                 * @member {string}ip
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.ip = "";

	                /**
	                 * WorkerConfiguration port.
	                 * @member {string}port
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.port = "";

	                /**
	                 * WorkerConfiguration host.
	                 * @member {string}host
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.host = "";

	                /**
	                 * WorkerConfiguration initializedTime.
	                 * @member {string}initializedTime
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.initializedTime = "";

	                /**
	                 * WorkerConfiguration state.
	                 * @member {org.roylance.yadel.WorkerState}state
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.state = 0;

	                /**
	                 * WorkerConfiguration task.
	                 * @member {(org.roylance.yadel.ITask|null|undefined)}task
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.task = null;

	                /**
	                 * WorkerConfiguration dag.
	                 * @member {(org.roylance.yadel.IDag|null|undefined)}dag
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.dag = null;

	                /**
	                 * WorkerConfiguration minutesBeforeTaskReset.
	                 * @member {number|Long}minutesBeforeTaskReset
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.minutesBeforeTaskReset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

	                /**
	                 * WorkerConfiguration taskStartTime.
	                 * @member {string}taskStartTime
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.taskStartTime = "";

	                /**
	                 * WorkerConfiguration osBitVersion.
	                 * @member {org.roylance.yadel.OSBitVersion}osBitVersion
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.osBitVersion = 0;

	                /**
	                 * WorkerConfiguration osTypeVersion.
	                 * @member {org.roylance.yadel.OSTypeVersion}osTypeVersion
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.osTypeVersion = 0;

	                /**
	                 * WorkerConfiguration osMajorVersion.
	                 * @member {string}osMajorVersion
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.osMajorVersion = "";

	                /**
	                 * WorkerConfiguration osMinorVersion.
	                 * @member {string}osMinorVersion
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.osMinorVersion = "";

	                /**
	                 * WorkerConfiguration osBuildVersion.
	                 * @member {string}osBuildVersion
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.osBuildVersion = "";

	                /**
	                 * WorkerConfiguration properties.
	                 * @member {Array.<org.roylance.yadel.IWorkerProperty>}properties
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 */
	                WorkerConfiguration.prototype.properties = $util.emptyArray;

	                /**
	                 * Creates a new WorkerConfiguration instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerConfiguration=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.WorkerConfiguration} WorkerConfiguration instance
	                 */
	                WorkerConfiguration.create = function create(properties) {
	                    return new WorkerConfiguration(properties);
	                };

	                /**
	                 * Encodes the specified WorkerConfiguration message. Does not implicitly {@link org.roylance.yadel.WorkerConfiguration.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerConfiguration} message WorkerConfiguration message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerConfiguration.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ip);
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.port);
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.host);
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.initializedTime);
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
	                    if (message.task != null && message.hasOwnProperty("task"))
	                        $root.org.roylance.yadel.Task.encode(message.task, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
	                    if (message.dag != null && message.hasOwnProperty("dag"))
	                        $root.org.roylance.yadel.Dag.encode(message.dag, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.minutesBeforeTaskReset);
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.taskStartTime);
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.osBitVersion);
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.osTypeVersion);
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.osMajorVersion);
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.osMinorVersion);
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.osBuildVersion);
	                    if (message.properties != null && message.properties.length)
	                        for (var i = 0; i < message.properties.length; ++i)
	                            $root.org.roylance.yadel.WorkerProperty.encode(message.properties[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified WorkerConfiguration message, length delimited. Does not implicitly {@link org.roylance.yadel.WorkerConfiguration.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerConfiguration} message WorkerConfiguration message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a WorkerConfiguration message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.WorkerConfiguration} WorkerConfiguration
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerConfiguration.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.WorkerConfiguration();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.ip = reader.string();
	                            break;
	                        case 3:
	                            message.port = reader.string();
	                            break;
	                        case 4:
	                            message.host = reader.string();
	                            break;
	                        case 5:
	                            message.initializedTime = reader.string();
	                            break;
	                        case 6:
	                            message.state = reader.int32();
	                            break;
	                        case 7:
	                            message.task = $root.org.roylance.yadel.Task.decode(reader, reader.uint32());
	                            break;
	                        case 8:
	                            message.dag = $root.org.roylance.yadel.Dag.decode(reader, reader.uint32());
	                            break;
	                        case 9:
	                            message.minutesBeforeTaskReset = reader.uint64();
	                            break;
	                        case 10:
	                            message.taskStartTime = reader.string();
	                            break;
	                        case 11:
	                            message.osBitVersion = reader.int32();
	                            break;
	                        case 12:
	                            message.osTypeVersion = reader.int32();
	                            break;
	                        case 13:
	                            message.osMajorVersion = reader.string();
	                            break;
	                        case 14:
	                            message.osMinorVersion = reader.string();
	                            break;
	                        case 15:
	                            message.osBuildVersion = reader.string();
	                            break;
	                        case 16:
	                            if (!(message.properties && message.properties.length))
	                                message.properties = [];
	                            message.properties.push($root.org.roylance.yadel.WorkerProperty.decode(reader, reader.uint32()));
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a WorkerConfiguration message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.WorkerConfiguration} WorkerConfiguration
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerConfiguration.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a WorkerConfiguration message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                WorkerConfiguration.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        if (!$util.isString(message.ip))
	                            return "ip: string expected";
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        if (!$util.isString(message.port))
	                            return "port: string expected";
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        if (!$util.isString(message.host))
	                            return "host: string expected";
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        if (!$util.isString(message.initializedTime))
	                            return "initializedTime: string expected";
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        switch (message.state) {
	                        default:
	                            return "state: enum value expected";
	                        case 0:
	                        case 1:
	                            break;
	                        }
	                    if (message.task != null && message.hasOwnProperty("task")) {
	                        var error = $root.org.roylance.yadel.Task.verify(message.task);
	                        if (error)
	                            return "task." + error;
	                    }
	                    if (message.dag != null && message.hasOwnProperty("dag")) {
	                        error = $root.org.roylance.yadel.Dag.verify(message.dag);
	                        if (error)
	                            return "dag." + error;
	                    }
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        if (!$util.isInteger(message.minutesBeforeTaskReset) && !(message.minutesBeforeTaskReset && $util.isInteger(message.minutesBeforeTaskReset.low) && $util.isInteger(message.minutesBeforeTaskReset.high)))
	                            return "minutesBeforeTaskReset: integer|Long expected";
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        if (!$util.isString(message.taskStartTime))
	                            return "taskStartTime: string expected";
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        switch (message.osBitVersion) {
	                        default:
	                            return "osBitVersion: enum value expected";
	                        case 0:
	                        case 1:
	                            break;
	                        }
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        switch (message.osTypeVersion) {
	                        default:
	                            return "osTypeVersion: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                            break;
	                        }
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        if (!$util.isString(message.osMajorVersion))
	                            return "osMajorVersion: string expected";
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        if (!$util.isString(message.osMinorVersion))
	                            return "osMinorVersion: string expected";
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        if (!$util.isString(message.osBuildVersion))
	                            return "osBuildVersion: string expected";
	                    if (message.properties != null && message.hasOwnProperty("properties")) {
	                        if (!Array.isArray(message.properties))
	                            return "properties: array expected";
	                        for (var i = 0; i < message.properties.length; ++i) {
	                            error = $root.org.roylance.yadel.WorkerProperty.verify(message.properties[i]);
	                            if (error)
	                                return "properties." + error;
	                        }
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a WorkerConfiguration message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.WorkerConfiguration} WorkerConfiguration
	                 */
	                WorkerConfiguration.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.WorkerConfiguration)
	                        return object;
	                    var message = new $root.org.roylance.yadel.WorkerConfiguration();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.ip != null)
	                        message.ip = String(object.ip);
	                    if (object.port != null)
	                        message.port = String(object.port);
	                    if (object.host != null)
	                        message.host = String(object.host);
	                    if (object.initializedTime != null)
	                        message.initializedTime = String(object.initializedTime);
	                    switch (object.state) {
	                    case "WORKING":
	                    case 0:
	                        message.state = 0;
	                        break;
	                    case "IDLE":
	                    case 1:
	                        message.state = 1;
	                        break;
	                    }
	                    if (object.task != null) {
	                        if (typeof object.task !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerConfiguration.task: object expected");
	                        message.task = $root.org.roylance.yadel.Task.fromObject(object.task);
	                    }
	                    if (object.dag != null) {
	                        if (typeof object.dag !== "object")
	                            throw TypeError(".org.roylance.yadel.WorkerConfiguration.dag: object expected");
	                        message.dag = $root.org.roylance.yadel.Dag.fromObject(object.dag);
	                    }
	                    if (object.minutesBeforeTaskReset != null)
	                        if ($util.Long)
	                            (message.minutesBeforeTaskReset = $util.Long.fromValue(object.minutesBeforeTaskReset)).unsigned = true;
	                        else if (typeof object.minutesBeforeTaskReset === "string")
	                            message.minutesBeforeTaskReset = parseInt(object.minutesBeforeTaskReset, 10);
	                        else if (typeof object.minutesBeforeTaskReset === "number")
	                            message.minutesBeforeTaskReset = object.minutesBeforeTaskReset;
	                        else if (typeof object.minutesBeforeTaskReset === "object")
	                            message.minutesBeforeTaskReset = new $util.LongBits(object.minutesBeforeTaskReset.low >>> 0, object.minutesBeforeTaskReset.high >>> 0).toNumber(true);
	                    if (object.taskStartTime != null)
	                        message.taskStartTime = String(object.taskStartTime);
	                    switch (object.osBitVersion) {
	                    case "V_64_BIT_VERSION":
	                    case 0:
	                        message.osBitVersion = 0;
	                        break;
	                    case "V_32_BIT_VERSION":
	                    case 1:
	                        message.osBitVersion = 1;
	                        break;
	                    }
	                    switch (object.osTypeVersion) {
	                    case "MAC_OS_TYPE_VERSION":
	                    case 0:
	                        message.osTypeVersion = 0;
	                        break;
	                    case "WIN_OS_TYPE_VERSION":
	                    case 1:
	                        message.osTypeVersion = 1;
	                        break;
	                    case "UBUNTU_OS_TYPE_VERSION":
	                    case 2:
	                        message.osTypeVersion = 2;
	                        break;
	                    case "CENTOS_OS_TYPE_VERSION":
	                    case 3:
	                        message.osTypeVersion = 3;
	                        break;
	                    case "FEDORA_OS_TYPE_VERSION":
	                    case 4:
	                        message.osTypeVersion = 4;
	                        break;
	                    case "REDHAT_OS_TYPE_VERSION":
	                    case 5:
	                        message.osTypeVersion = 5;
	                        break;
	                    case "LINUX_OS_TYPE_VERSION":
	                    case 6:
	                        message.osTypeVersion = 6;
	                        break;
	                    }
	                    if (object.osMajorVersion != null)
	                        message.osMajorVersion = String(object.osMajorVersion);
	                    if (object.osMinorVersion != null)
	                        message.osMinorVersion = String(object.osMinorVersion);
	                    if (object.osBuildVersion != null)
	                        message.osBuildVersion = String(object.osBuildVersion);
	                    if (object.properties) {
	                        if (!Array.isArray(object.properties))
	                            throw TypeError(".org.roylance.yadel.WorkerConfiguration.properties: array expected");
	                        message.properties = [];
	                        for (var i = 0; i < object.properties.length; ++i) {
	                            if (typeof object.properties[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.WorkerConfiguration.properties: object expected");
	                            message.properties[i] = $root.org.roylance.yadel.WorkerProperty.fromObject(object.properties[i]);
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a WorkerConfiguration message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @static
	                 * @param {org.roylance.yadel.WorkerConfiguration} message WorkerConfiguration
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                WorkerConfiguration.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults)
	                        object.properties = [];
	                    if (options.defaults) {
	                        object.id = "";
	                        object.ip = "";
	                        object.port = "";
	                        object.host = "";
	                        object.initializedTime = "";
	                        object.state = options.enums === String ? "WORKING" : 0;
	                        object.task = null;
	                        object.dag = null;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, true);
	                            object.minutesBeforeTaskReset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.minutesBeforeTaskReset = options.longs === String ? "0" : 0;
	                        object.taskStartTime = "";
	                        object.osBitVersion = options.enums === String ? "V_64_BIT_VERSION" : 0;
	                        object.osTypeVersion = options.enums === String ? "MAC_OS_TYPE_VERSION" : 0;
	                        object.osMajorVersion = "";
	                        object.osMinorVersion = "";
	                        object.osBuildVersion = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.ip != null && message.hasOwnProperty("ip"))
	                        object.ip = message.ip;
	                    if (message.port != null && message.hasOwnProperty("port"))
	                        object.port = message.port;
	                    if (message.host != null && message.hasOwnProperty("host"))
	                        object.host = message.host;
	                    if (message.initializedTime != null && message.hasOwnProperty("initializedTime"))
	                        object.initializedTime = message.initializedTime;
	                    if (message.state != null && message.hasOwnProperty("state"))
	                        object.state = options.enums === String ? $root.org.roylance.yadel.WorkerState[message.state] : message.state;
	                    if (message.task != null && message.hasOwnProperty("task"))
	                        object.task = $root.org.roylance.yadel.Task.toObject(message.task, options);
	                    if (message.dag != null && message.hasOwnProperty("dag"))
	                        object.dag = $root.org.roylance.yadel.Dag.toObject(message.dag, options);
	                    if (message.minutesBeforeTaskReset != null && message.hasOwnProperty("minutesBeforeTaskReset"))
	                        if (typeof message.minutesBeforeTaskReset === "number")
	                            object.minutesBeforeTaskReset = options.longs === String ? String(message.minutesBeforeTaskReset) : message.minutesBeforeTaskReset;
	                        else
	                            object.minutesBeforeTaskReset = options.longs === String ? $util.Long.prototype.toString.call(message.minutesBeforeTaskReset) : options.longs === Number ? new $util.LongBits(message.minutesBeforeTaskReset.low >>> 0, message.minutesBeforeTaskReset.high >>> 0).toNumber(true) : message.minutesBeforeTaskReset;
	                    if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
	                        object.taskStartTime = message.taskStartTime;
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        object.osBitVersion = options.enums === String ? $root.org.roylance.yadel.OSBitVersion[message.osBitVersion] : message.osBitVersion;
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        object.osTypeVersion = options.enums === String ? $root.org.roylance.yadel.OSTypeVersion[message.osTypeVersion] : message.osTypeVersion;
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        object.osMajorVersion = message.osMajorVersion;
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        object.osMinorVersion = message.osMinorVersion;
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        object.osBuildVersion = message.osBuildVersion;
	                    if (message.properties && message.properties.length) {
	                        object.properties = [];
	                        for (var j = 0; j < message.properties.length; ++j)
	                            object.properties[j] = $root.org.roylance.yadel.WorkerProperty.toObject(message.properties[j], options);
	                    }
	                    return object;
	                };

	                /**
	                 * Converts this WorkerConfiguration to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.WorkerConfiguration
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                WorkerConfiguration.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return WorkerConfiguration;
	            })();

	            yadel.Log = (function() {

	                /**
	                 * Properties of a Log.
	                 * @memberof org.roylance.yadel
	                 * @interface ILog
	                 * @property {string} [id] Log id
	                 * @property {string} [message] Log message
	                 */

	                /**
	                 * Constructs a new Log.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a Log.
	                 * @constructor
	                 * @param {org.roylance.yadel.ILog=} [properties] Properties to set
	                 */
	                function Log(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * Log id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.Log
	                 * @instance
	                 */
	                Log.prototype.id = "";

	                /**
	                 * Log message.
	                 * @member {string}message
	                 * @memberof org.roylance.yadel.Log
	                 * @instance
	                 */
	                Log.prototype.message = "";

	                /**
	                 * Creates a new Log instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {org.roylance.yadel.ILog=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.Log} Log instance
	                 */
	                Log.create = function create(properties) {
	                    return new Log(properties);
	                };

	                /**
	                 * Encodes the specified Log message. Does not implicitly {@link org.roylance.yadel.Log.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {org.roylance.yadel.ILog} message Log message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Log.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified Log message, length delimited. Does not implicitly {@link org.roylance.yadel.Log.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {org.roylance.yadel.ILog} message Log message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Log.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a Log message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.Log} Log
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Log.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.Log();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.message = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a Log message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.Log} Log
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Log.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a Log message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                Log.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        if (!$util.isString(message.message))
	                            return "message: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a Log message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.Log} Log
	                 */
	                Log.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.Log)
	                        return object;
	                    var message = new $root.org.roylance.yadel.Log();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.message != null)
	                        message.message = String(object.message);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a Log message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.Log
	                 * @static
	                 * @param {org.roylance.yadel.Log} message Log
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                Log.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.message = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.message != null && message.hasOwnProperty("message"))
	                        object.message = message.message;
	                    return object;
	                };

	                /**
	                 * Converts this Log to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.Log
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                Log.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return Log;
	            })();

	            yadel.Dag = (function() {

	                /**
	                 * Properties of a Dag.
	                 * @memberof org.roylance.yadel
	                 * @interface IDag
	                 * @property {string} [id] Dag id
	                 * @property {string} [display] Dag display
	                 * @property {Array.<org.roylance.yadel.ITask>} [flattenedTasks] Dag flattenedTasks
	                 * @property {number|Long} [executionDate] Dag executionDate
	                 * @property {number|Long} [startDate] Dag startDate
	                 * @property {number|Long} [endDate] Dag endDate
	                 * @property {number|Long} [duration] Dag duration
	                 * @property {Array.<org.roylance.yadel.ITask>} [uncompletedTasks] Dag uncompletedTasks
	                 * @property {Array.<org.roylance.yadel.ITask>} [processingTasks] Dag processingTasks
	                 * @property {Array.<org.roylance.yadel.ITask>} [erroredTasks] Dag erroredTasks
	                 * @property {Array.<org.roylance.yadel.ITask>} [completedTasks] Dag completedTasks
	                 * @property {org.roylance.yadel.IDag} [parent] Dag parent
	                 */

	                /**
	                 * Constructs a new Dag.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a Dag.
	                 * @constructor
	                 * @param {org.roylance.yadel.IDag=} [properties] Properties to set
	                 */
	                function Dag(properties) {
	                    this.flattenedTasks = [];
	                    this.uncompletedTasks = [];
	                    this.processingTasks = [];
	                    this.erroredTasks = [];
	                    this.completedTasks = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * Dag id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.id = "";

	                /**
	                 * Dag display.
	                 * @member {string}display
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.display = "";

	                /**
	                 * Dag flattenedTasks.
	                 * @member {Array.<org.roylance.yadel.ITask>}flattenedTasks
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.flattenedTasks = $util.emptyArray;

	                /**
	                 * Dag executionDate.
	                 * @member {number|Long}executionDate
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.executionDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Dag startDate.
	                 * @member {number|Long}startDate
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.startDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Dag endDate.
	                 * @member {number|Long}endDate
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.endDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Dag duration.
	                 * @member {number|Long}duration
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Dag uncompletedTasks.
	                 * @member {Array.<org.roylance.yadel.ITask>}uncompletedTasks
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.uncompletedTasks = $util.emptyArray;

	                /**
	                 * Dag processingTasks.
	                 * @member {Array.<org.roylance.yadel.ITask>}processingTasks
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.processingTasks = $util.emptyArray;

	                /**
	                 * Dag erroredTasks.
	                 * @member {Array.<org.roylance.yadel.ITask>}erroredTasks
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.erroredTasks = $util.emptyArray;

	                /**
	                 * Dag completedTasks.
	                 * @member {Array.<org.roylance.yadel.ITask>}completedTasks
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.completedTasks = $util.emptyArray;

	                /**
	                 * Dag parent.
	                 * @member {(org.roylance.yadel.IDag|null|undefined)}parent
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 */
	                Dag.prototype.parent = null;

	                /**
	                 * Creates a new Dag instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {org.roylance.yadel.IDag=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.Dag} Dag instance
	                 */
	                Dag.create = function create(properties) {
	                    return new Dag(properties);
	                };

	                /**
	                 * Encodes the specified Dag message. Does not implicitly {@link org.roylance.yadel.Dag.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {org.roylance.yadel.IDag} message Dag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Dag.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.display);
	                    if (message.flattenedTasks != null && message.flattenedTasks.length)
	                        for (var i = 0; i < message.flattenedTasks.length; ++i)
	                            $root.org.roylance.yadel.Task.encode(message.flattenedTasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.executionDate);
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startDate);
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.endDate);
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.duration);
	                    if (message.uncompletedTasks != null && message.uncompletedTasks.length)
	                        for (var i = 0; i < message.uncompletedTasks.length; ++i)
	                            $root.org.roylance.yadel.Task.encode(message.uncompletedTasks[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
	                    if (message.processingTasks != null && message.processingTasks.length)
	                        for (var i = 0; i < message.processingTasks.length; ++i)
	                            $root.org.roylance.yadel.Task.encode(message.processingTasks[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
	                    if (message.erroredTasks != null && message.erroredTasks.length)
	                        for (var i = 0; i < message.erroredTasks.length; ++i)
	                            $root.org.roylance.yadel.Task.encode(message.erroredTasks[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
	                    if (message.completedTasks != null && message.completedTasks.length)
	                        for (var i = 0; i < message.completedTasks.length; ++i)
	                            $root.org.roylance.yadel.Task.encode(message.completedTasks[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
	                    if (message.parent != null && message.hasOwnProperty("parent"))
	                        $root.org.roylance.yadel.Dag.encode(message.parent, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified Dag message, length delimited. Does not implicitly {@link org.roylance.yadel.Dag.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {org.roylance.yadel.IDag} message Dag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Dag.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a Dag message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.Dag} Dag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Dag.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.Dag();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.display = reader.string();
	                            break;
	                        case 3:
	                            if (!(message.flattenedTasks && message.flattenedTasks.length))
	                                message.flattenedTasks = [];
	                            message.flattenedTasks.push($root.org.roylance.yadel.Task.decode(reader, reader.uint32()));
	                            break;
	                        case 4:
	                            message.executionDate = reader.int64();
	                            break;
	                        case 5:
	                            message.startDate = reader.int64();
	                            break;
	                        case 6:
	                            message.endDate = reader.int64();
	                            break;
	                        case 7:
	                            message.duration = reader.int64();
	                            break;
	                        case 8:
	                            if (!(message.uncompletedTasks && message.uncompletedTasks.length))
	                                message.uncompletedTasks = [];
	                            message.uncompletedTasks.push($root.org.roylance.yadel.Task.decode(reader, reader.uint32()));
	                            break;
	                        case 9:
	                            if (!(message.processingTasks && message.processingTasks.length))
	                                message.processingTasks = [];
	                            message.processingTasks.push($root.org.roylance.yadel.Task.decode(reader, reader.uint32()));
	                            break;
	                        case 10:
	                            if (!(message.erroredTasks && message.erroredTasks.length))
	                                message.erroredTasks = [];
	                            message.erroredTasks.push($root.org.roylance.yadel.Task.decode(reader, reader.uint32()));
	                            break;
	                        case 11:
	                            if (!(message.completedTasks && message.completedTasks.length))
	                                message.completedTasks = [];
	                            message.completedTasks.push($root.org.roylance.yadel.Task.decode(reader, reader.uint32()));
	                            break;
	                        case 12:
	                            message.parent = $root.org.roylance.yadel.Dag.decode(reader, reader.uint32());
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a Dag message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.Dag} Dag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Dag.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a Dag message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                Dag.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        if (!$util.isString(message.display))
	                            return "display: string expected";
	                    if (message.flattenedTasks != null && message.hasOwnProperty("flattenedTasks")) {
	                        if (!Array.isArray(message.flattenedTasks))
	                            return "flattenedTasks: array expected";
	                        for (var i = 0; i < message.flattenedTasks.length; ++i) {
	                            var error = $root.org.roylance.yadel.Task.verify(message.flattenedTasks[i]);
	                            if (error)
	                                return "flattenedTasks." + error;
	                        }
	                    }
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (!$util.isInteger(message.executionDate) && !(message.executionDate && $util.isInteger(message.executionDate.low) && $util.isInteger(message.executionDate.high)))
	                            return "executionDate: integer|Long expected";
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (!$util.isInteger(message.startDate) && !(message.startDate && $util.isInteger(message.startDate.low) && $util.isInteger(message.startDate.high)))
	                            return "startDate: integer|Long expected";
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (!$util.isInteger(message.endDate) && !(message.endDate && $util.isInteger(message.endDate.low) && $util.isInteger(message.endDate.high)))
	                            return "endDate: integer|Long expected";
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
	                            return "duration: integer|Long expected";
	                    if (message.uncompletedTasks != null && message.hasOwnProperty("uncompletedTasks")) {
	                        if (!Array.isArray(message.uncompletedTasks))
	                            return "uncompletedTasks: array expected";
	                        for (var i = 0; i < message.uncompletedTasks.length; ++i) {
	                            error = $root.org.roylance.yadel.Task.verify(message.uncompletedTasks[i]);
	                            if (error)
	                                return "uncompletedTasks." + error;
	                        }
	                    }
	                    if (message.processingTasks != null && message.hasOwnProperty("processingTasks")) {
	                        if (!Array.isArray(message.processingTasks))
	                            return "processingTasks: array expected";
	                        for (var i = 0; i < message.processingTasks.length; ++i) {
	                            error = $root.org.roylance.yadel.Task.verify(message.processingTasks[i]);
	                            if (error)
	                                return "processingTasks." + error;
	                        }
	                    }
	                    if (message.erroredTasks != null && message.hasOwnProperty("erroredTasks")) {
	                        if (!Array.isArray(message.erroredTasks))
	                            return "erroredTasks: array expected";
	                        for (var i = 0; i < message.erroredTasks.length; ++i) {
	                            error = $root.org.roylance.yadel.Task.verify(message.erroredTasks[i]);
	                            if (error)
	                                return "erroredTasks." + error;
	                        }
	                    }
	                    if (message.completedTasks != null && message.hasOwnProperty("completedTasks")) {
	                        if (!Array.isArray(message.completedTasks))
	                            return "completedTasks: array expected";
	                        for (var i = 0; i < message.completedTasks.length; ++i) {
	                            error = $root.org.roylance.yadel.Task.verify(message.completedTasks[i]);
	                            if (error)
	                                return "completedTasks." + error;
	                        }
	                    }
	                    if (message.parent != null && message.hasOwnProperty("parent")) {
	                        error = $root.org.roylance.yadel.Dag.verify(message.parent);
	                        if (error)
	                            return "parent." + error;
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a Dag message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.Dag} Dag
	                 */
	                Dag.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.Dag)
	                        return object;
	                    var message = new $root.org.roylance.yadel.Dag();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.display != null)
	                        message.display = String(object.display);
	                    if (object.flattenedTasks) {
	                        if (!Array.isArray(object.flattenedTasks))
	                            throw TypeError(".org.roylance.yadel.Dag.flattenedTasks: array expected");
	                        message.flattenedTasks = [];
	                        for (var i = 0; i < object.flattenedTasks.length; ++i) {
	                            if (typeof object.flattenedTasks[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Dag.flattenedTasks: object expected");
	                            message.flattenedTasks[i] = $root.org.roylance.yadel.Task.fromObject(object.flattenedTasks[i]);
	                        }
	                    }
	                    if (object.executionDate != null)
	                        if ($util.Long)
	                            (message.executionDate = $util.Long.fromValue(object.executionDate)).unsigned = false;
	                        else if (typeof object.executionDate === "string")
	                            message.executionDate = parseInt(object.executionDate, 10);
	                        else if (typeof object.executionDate === "number")
	                            message.executionDate = object.executionDate;
	                        else if (typeof object.executionDate === "object")
	                            message.executionDate = new $util.LongBits(object.executionDate.low >>> 0, object.executionDate.high >>> 0).toNumber();
	                    if (object.startDate != null)
	                        if ($util.Long)
	                            (message.startDate = $util.Long.fromValue(object.startDate)).unsigned = false;
	                        else if (typeof object.startDate === "string")
	                            message.startDate = parseInt(object.startDate, 10);
	                        else if (typeof object.startDate === "number")
	                            message.startDate = object.startDate;
	                        else if (typeof object.startDate === "object")
	                            message.startDate = new $util.LongBits(object.startDate.low >>> 0, object.startDate.high >>> 0).toNumber();
	                    if (object.endDate != null)
	                        if ($util.Long)
	                            (message.endDate = $util.Long.fromValue(object.endDate)).unsigned = false;
	                        else if (typeof object.endDate === "string")
	                            message.endDate = parseInt(object.endDate, 10);
	                        else if (typeof object.endDate === "number")
	                            message.endDate = object.endDate;
	                        else if (typeof object.endDate === "object")
	                            message.endDate = new $util.LongBits(object.endDate.low >>> 0, object.endDate.high >>> 0).toNumber();
	                    if (object.duration != null)
	                        if ($util.Long)
	                            (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
	                        else if (typeof object.duration === "string")
	                            message.duration = parseInt(object.duration, 10);
	                        else if (typeof object.duration === "number")
	                            message.duration = object.duration;
	                        else if (typeof object.duration === "object")
	                            message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
	                    if (object.uncompletedTasks) {
	                        if (!Array.isArray(object.uncompletedTasks))
	                            throw TypeError(".org.roylance.yadel.Dag.uncompletedTasks: array expected");
	                        message.uncompletedTasks = [];
	                        for (var i = 0; i < object.uncompletedTasks.length; ++i) {
	                            if (typeof object.uncompletedTasks[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Dag.uncompletedTasks: object expected");
	                            message.uncompletedTasks[i] = $root.org.roylance.yadel.Task.fromObject(object.uncompletedTasks[i]);
	                        }
	                    }
	                    if (object.processingTasks) {
	                        if (!Array.isArray(object.processingTasks))
	                            throw TypeError(".org.roylance.yadel.Dag.processingTasks: array expected");
	                        message.processingTasks = [];
	                        for (var i = 0; i < object.processingTasks.length; ++i) {
	                            if (typeof object.processingTasks[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Dag.processingTasks: object expected");
	                            message.processingTasks[i] = $root.org.roylance.yadel.Task.fromObject(object.processingTasks[i]);
	                        }
	                    }
	                    if (object.erroredTasks) {
	                        if (!Array.isArray(object.erroredTasks))
	                            throw TypeError(".org.roylance.yadel.Dag.erroredTasks: array expected");
	                        message.erroredTasks = [];
	                        for (var i = 0; i < object.erroredTasks.length; ++i) {
	                            if (typeof object.erroredTasks[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Dag.erroredTasks: object expected");
	                            message.erroredTasks[i] = $root.org.roylance.yadel.Task.fromObject(object.erroredTasks[i]);
	                        }
	                    }
	                    if (object.completedTasks) {
	                        if (!Array.isArray(object.completedTasks))
	                            throw TypeError(".org.roylance.yadel.Dag.completedTasks: array expected");
	                        message.completedTasks = [];
	                        for (var i = 0; i < object.completedTasks.length; ++i) {
	                            if (typeof object.completedTasks[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Dag.completedTasks: object expected");
	                            message.completedTasks[i] = $root.org.roylance.yadel.Task.fromObject(object.completedTasks[i]);
	                        }
	                    }
	                    if (object.parent != null) {
	                        if (typeof object.parent !== "object")
	                            throw TypeError(".org.roylance.yadel.Dag.parent: object expected");
	                        message.parent = $root.org.roylance.yadel.Dag.fromObject(object.parent);
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a Dag message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.Dag
	                 * @static
	                 * @param {org.roylance.yadel.Dag} message Dag
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                Dag.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults) {
	                        object.flattenedTasks = [];
	                        object.uncompletedTasks = [];
	                        object.processingTasks = [];
	                        object.erroredTasks = [];
	                        object.completedTasks = [];
	                    }
	                    if (options.defaults) {
	                        object.id = "";
	                        object.display = "";
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.executionDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.executionDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.startDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.startDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.endDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.endDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.duration = options.longs === String ? "0" : 0;
	                        object.parent = null;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        object.display = message.display;
	                    if (message.flattenedTasks && message.flattenedTasks.length) {
	                        object.flattenedTasks = [];
	                        for (var j = 0; j < message.flattenedTasks.length; ++j)
	                            object.flattenedTasks[j] = $root.org.roylance.yadel.Task.toObject(message.flattenedTasks[j], options);
	                    }
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (typeof message.executionDate === "number")
	                            object.executionDate = options.longs === String ? String(message.executionDate) : message.executionDate;
	                        else
	                            object.executionDate = options.longs === String ? $util.Long.prototype.toString.call(message.executionDate) : options.longs === Number ? new $util.LongBits(message.executionDate.low >>> 0, message.executionDate.high >>> 0).toNumber() : message.executionDate;
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (typeof message.startDate === "number")
	                            object.startDate = options.longs === String ? String(message.startDate) : message.startDate;
	                        else
	                            object.startDate = options.longs === String ? $util.Long.prototype.toString.call(message.startDate) : options.longs === Number ? new $util.LongBits(message.startDate.low >>> 0, message.startDate.high >>> 0).toNumber() : message.startDate;
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (typeof message.endDate === "number")
	                            object.endDate = options.longs === String ? String(message.endDate) : message.endDate;
	                        else
	                            object.endDate = options.longs === String ? $util.Long.prototype.toString.call(message.endDate) : options.longs === Number ? new $util.LongBits(message.endDate.low >>> 0, message.endDate.high >>> 0).toNumber() : message.endDate;
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (typeof message.duration === "number")
	                            object.duration = options.longs === String ? String(message.duration) : message.duration;
	                        else
	                            object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
	                    if (message.uncompletedTasks && message.uncompletedTasks.length) {
	                        object.uncompletedTasks = [];
	                        for (var j = 0; j < message.uncompletedTasks.length; ++j)
	                            object.uncompletedTasks[j] = $root.org.roylance.yadel.Task.toObject(message.uncompletedTasks[j], options);
	                    }
	                    if (message.processingTasks && message.processingTasks.length) {
	                        object.processingTasks = [];
	                        for (var j = 0; j < message.processingTasks.length; ++j)
	                            object.processingTasks[j] = $root.org.roylance.yadel.Task.toObject(message.processingTasks[j], options);
	                    }
	                    if (message.erroredTasks && message.erroredTasks.length) {
	                        object.erroredTasks = [];
	                        for (var j = 0; j < message.erroredTasks.length; ++j)
	                            object.erroredTasks[j] = $root.org.roylance.yadel.Task.toObject(message.erroredTasks[j], options);
	                    }
	                    if (message.completedTasks && message.completedTasks.length) {
	                        object.completedTasks = [];
	                        for (var j = 0; j < message.completedTasks.length; ++j)
	                            object.completedTasks[j] = $root.org.roylance.yadel.Task.toObject(message.completedTasks[j], options);
	                    }
	                    if (message.parent != null && message.hasOwnProperty("parent"))
	                        object.parent = $root.org.roylance.yadel.Dag.toObject(message.parent, options);
	                    return object;
	                };

	                /**
	                 * Converts this Dag to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.Dag
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                Dag.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return Dag;
	            })();

	            yadel.Task = (function() {

	                /**
	                 * Properties of a Task.
	                 * @memberof org.roylance.yadel
	                 * @interface ITask
	                 * @property {string} [id] Task id
	                 * @property {string} [display] Task display
	                 * @property {Array.<org.roylance.yadel.ITaskDependency>} [dependencies] Task dependencies
	                 * @property {string} [dagId] Task dagId
	                 * @property {Array.<org.roylance.yadel.ILog>} [logs] Task logs
	                 * @property {number|Long} [executionDate] Task executionDate
	                 * @property {number|Long} [startDate] Task startDate
	                 * @property {number|Long} [endDate] Task endDate
	                 * @property {number|Long} [duration] Task duration
	                 * @property {string} [firstContextBase_64] Task firstContextBase_64
	                 * @property {string} [secondContextBase_64] Task secondContextBase_64
	                 * @property {string} [thirdContextBase_64] Task thirdContextBase_64
	                 * @property {boolean} [isWaitingForAnotherDagTask] Task isWaitingForAnotherDagTask
	                 * @property {Array.<org.roylance.yadel.IWorkerFilter>} [filters] Task filters
	                 */

	                /**
	                 * Constructs a new Task.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a Task.
	                 * @constructor
	                 * @param {org.roylance.yadel.ITask=} [properties] Properties to set
	                 */
	                function Task(properties) {
	                    this.dependencies = [];
	                    this.logs = [];
	                    this.filters = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * Task id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.id = "";

	                /**
	                 * Task display.
	                 * @member {string}display
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.display = "";

	                /**
	                 * Task dependencies.
	                 * @member {Array.<org.roylance.yadel.ITaskDependency>}dependencies
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.dependencies = $util.emptyArray;

	                /**
	                 * Task dagId.
	                 * @member {string}dagId
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.dagId = "";

	                /**
	                 * Task logs.
	                 * @member {Array.<org.roylance.yadel.ILog>}logs
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.logs = $util.emptyArray;

	                /**
	                 * Task executionDate.
	                 * @member {number|Long}executionDate
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.executionDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Task startDate.
	                 * @member {number|Long}startDate
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.startDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Task endDate.
	                 * @member {number|Long}endDate
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.endDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Task duration.
	                 * @member {number|Long}duration
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

	                /**
	                 * Task firstContextBase_64.
	                 * @member {string}firstContextBase_64
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.firstContextBase_64 = "";

	                /**
	                 * Task secondContextBase_64.
	                 * @member {string}secondContextBase_64
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.secondContextBase_64 = "";

	                /**
	                 * Task thirdContextBase_64.
	                 * @member {string}thirdContextBase_64
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.thirdContextBase_64 = "";

	                /**
	                 * Task isWaitingForAnotherDagTask.
	                 * @member {boolean}isWaitingForAnotherDagTask
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.isWaitingForAnotherDagTask = false;

	                /**
	                 * Task filters.
	                 * @member {Array.<org.roylance.yadel.IWorkerFilter>}filters
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 */
	                Task.prototype.filters = $util.emptyArray;

	                /**
	                 * Creates a new Task instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {org.roylance.yadel.ITask=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.Task} Task instance
	                 */
	                Task.create = function create(properties) {
	                    return new Task(properties);
	                };

	                /**
	                 * Encodes the specified Task message. Does not implicitly {@link org.roylance.yadel.Task.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {org.roylance.yadel.ITask} message Task message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Task.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.display);
	                    if (message.dependencies != null && message.dependencies.length)
	                        for (var i = 0; i < message.dependencies.length; ++i)
	                            $root.org.roylance.yadel.TaskDependency.encode(message.dependencies[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.dagId);
	                    if (message.logs != null && message.logs.length)
	                        for (var i = 0; i < message.logs.length; ++i)
	                            $root.org.roylance.yadel.Log.encode(message.logs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.executionDate);
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.startDate);
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        writer.uint32(/* id 8, wireType 0 =*/64).int64(message.endDate);
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.duration);
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.firstContextBase_64);
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.secondContextBase_64);
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.thirdContextBase_64);
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.isWaitingForAnotherDagTask);
	                    if (message.filters != null && message.filters.length)
	                        for (var i = 0; i < message.filters.length; ++i)
	                            $root.org.roylance.yadel.WorkerFilter.encode(message.filters[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified Task message, length delimited. Does not implicitly {@link org.roylance.yadel.Task.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {org.roylance.yadel.ITask} message Task message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                Task.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a Task message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.Task} Task
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Task.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.Task();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.display = reader.string();
	                            break;
	                        case 3:
	                            if (!(message.dependencies && message.dependencies.length))
	                                message.dependencies = [];
	                            message.dependencies.push($root.org.roylance.yadel.TaskDependency.decode(reader, reader.uint32()));
	                            break;
	                        case 4:
	                            message.dagId = reader.string();
	                            break;
	                        case 5:
	                            if (!(message.logs && message.logs.length))
	                                message.logs = [];
	                            message.logs.push($root.org.roylance.yadel.Log.decode(reader, reader.uint32()));
	                            break;
	                        case 6:
	                            message.executionDate = reader.int64();
	                            break;
	                        case 7:
	                            message.startDate = reader.int64();
	                            break;
	                        case 8:
	                            message.endDate = reader.int64();
	                            break;
	                        case 9:
	                            message.duration = reader.int64();
	                            break;
	                        case 10:
	                            message.firstContextBase_64 = reader.string();
	                            break;
	                        case 11:
	                            message.secondContextBase_64 = reader.string();
	                            break;
	                        case 12:
	                            message.thirdContextBase_64 = reader.string();
	                            break;
	                        case 13:
	                            message.isWaitingForAnotherDagTask = reader.bool();
	                            break;
	                        case 14:
	                            if (!(message.filters && message.filters.length))
	                                message.filters = [];
	                            message.filters.push($root.org.roylance.yadel.WorkerFilter.decode(reader, reader.uint32()));
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a Task message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.Task} Task
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                Task.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a Task message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                Task.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        if (!$util.isString(message.display))
	                            return "display: string expected";
	                    if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
	                        if (!Array.isArray(message.dependencies))
	                            return "dependencies: array expected";
	                        for (var i = 0; i < message.dependencies.length; ++i) {
	                            var error = $root.org.roylance.yadel.TaskDependency.verify(message.dependencies[i]);
	                            if (error)
	                                return "dependencies." + error;
	                        }
	                    }
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        if (!$util.isString(message.dagId))
	                            return "dagId: string expected";
	                    if (message.logs != null && message.hasOwnProperty("logs")) {
	                        if (!Array.isArray(message.logs))
	                            return "logs: array expected";
	                        for (var i = 0; i < message.logs.length; ++i) {
	                            error = $root.org.roylance.yadel.Log.verify(message.logs[i]);
	                            if (error)
	                                return "logs." + error;
	                        }
	                    }
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (!$util.isInteger(message.executionDate) && !(message.executionDate && $util.isInteger(message.executionDate.low) && $util.isInteger(message.executionDate.high)))
	                            return "executionDate: integer|Long expected";
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (!$util.isInteger(message.startDate) && !(message.startDate && $util.isInteger(message.startDate.low) && $util.isInteger(message.startDate.high)))
	                            return "startDate: integer|Long expected";
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (!$util.isInteger(message.endDate) && !(message.endDate && $util.isInteger(message.endDate.low) && $util.isInteger(message.endDate.high)))
	                            return "endDate: integer|Long expected";
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
	                            return "duration: integer|Long expected";
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        if (!$util.isString(message.firstContextBase_64))
	                            return "firstContextBase_64: string expected";
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        if (!$util.isString(message.secondContextBase_64))
	                            return "secondContextBase_64: string expected";
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        if (!$util.isString(message.thirdContextBase_64))
	                            return "thirdContextBase_64: string expected";
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        if (typeof message.isWaitingForAnotherDagTask !== "boolean")
	                            return "isWaitingForAnotherDagTask: boolean expected";
	                    if (message.filters != null && message.hasOwnProperty("filters")) {
	                        if (!Array.isArray(message.filters))
	                            return "filters: array expected";
	                        for (var i = 0; i < message.filters.length; ++i) {
	                            error = $root.org.roylance.yadel.WorkerFilter.verify(message.filters[i]);
	                            if (error)
	                                return "filters." + error;
	                        }
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a Task message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.Task} Task
	                 */
	                Task.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.Task)
	                        return object;
	                    var message = new $root.org.roylance.yadel.Task();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.display != null)
	                        message.display = String(object.display);
	                    if (object.dependencies) {
	                        if (!Array.isArray(object.dependencies))
	                            throw TypeError(".org.roylance.yadel.Task.dependencies: array expected");
	                        message.dependencies = [];
	                        for (var i = 0; i < object.dependencies.length; ++i) {
	                            if (typeof object.dependencies[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Task.dependencies: object expected");
	                            message.dependencies[i] = $root.org.roylance.yadel.TaskDependency.fromObject(object.dependencies[i]);
	                        }
	                    }
	                    if (object.dagId != null)
	                        message.dagId = String(object.dagId);
	                    if (object.logs) {
	                        if (!Array.isArray(object.logs))
	                            throw TypeError(".org.roylance.yadel.Task.logs: array expected");
	                        message.logs = [];
	                        for (var i = 0; i < object.logs.length; ++i) {
	                            if (typeof object.logs[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Task.logs: object expected");
	                            message.logs[i] = $root.org.roylance.yadel.Log.fromObject(object.logs[i]);
	                        }
	                    }
	                    if (object.executionDate != null)
	                        if ($util.Long)
	                            (message.executionDate = $util.Long.fromValue(object.executionDate)).unsigned = false;
	                        else if (typeof object.executionDate === "string")
	                            message.executionDate = parseInt(object.executionDate, 10);
	                        else if (typeof object.executionDate === "number")
	                            message.executionDate = object.executionDate;
	                        else if (typeof object.executionDate === "object")
	                            message.executionDate = new $util.LongBits(object.executionDate.low >>> 0, object.executionDate.high >>> 0).toNumber();
	                    if (object.startDate != null)
	                        if ($util.Long)
	                            (message.startDate = $util.Long.fromValue(object.startDate)).unsigned = false;
	                        else if (typeof object.startDate === "string")
	                            message.startDate = parseInt(object.startDate, 10);
	                        else if (typeof object.startDate === "number")
	                            message.startDate = object.startDate;
	                        else if (typeof object.startDate === "object")
	                            message.startDate = new $util.LongBits(object.startDate.low >>> 0, object.startDate.high >>> 0).toNumber();
	                    if (object.endDate != null)
	                        if ($util.Long)
	                            (message.endDate = $util.Long.fromValue(object.endDate)).unsigned = false;
	                        else if (typeof object.endDate === "string")
	                            message.endDate = parseInt(object.endDate, 10);
	                        else if (typeof object.endDate === "number")
	                            message.endDate = object.endDate;
	                        else if (typeof object.endDate === "object")
	                            message.endDate = new $util.LongBits(object.endDate.low >>> 0, object.endDate.high >>> 0).toNumber();
	                    if (object.duration != null)
	                        if ($util.Long)
	                            (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
	                        else if (typeof object.duration === "string")
	                            message.duration = parseInt(object.duration, 10);
	                        else if (typeof object.duration === "number")
	                            message.duration = object.duration;
	                        else if (typeof object.duration === "object")
	                            message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
	                    if (object.firstContextBase_64 != null)
	                        message.firstContextBase_64 = String(object.firstContextBase_64);
	                    if (object.secondContextBase_64 != null)
	                        message.secondContextBase_64 = String(object.secondContextBase_64);
	                    if (object.thirdContextBase_64 != null)
	                        message.thirdContextBase_64 = String(object.thirdContextBase_64);
	                    if (object.isWaitingForAnotherDagTask != null)
	                        message.isWaitingForAnotherDagTask = Boolean(object.isWaitingForAnotherDagTask);
	                    if (object.filters) {
	                        if (!Array.isArray(object.filters))
	                            throw TypeError(".org.roylance.yadel.Task.filters: array expected");
	                        message.filters = [];
	                        for (var i = 0; i < object.filters.length; ++i) {
	                            if (typeof object.filters[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.Task.filters: object expected");
	                            message.filters[i] = $root.org.roylance.yadel.WorkerFilter.fromObject(object.filters[i]);
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a Task message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.Task
	                 * @static
	                 * @param {org.roylance.yadel.Task} message Task
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                Task.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults) {
	                        object.dependencies = [];
	                        object.logs = [];
	                        object.filters = [];
	                    }
	                    if (options.defaults) {
	                        object.id = "";
	                        object.display = "";
	                        object.dagId = "";
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.executionDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.executionDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.startDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.startDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.endDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.endDate = options.longs === String ? "0" : 0;
	                        if ($util.Long) {
	                            var long = new $util.Long(0, 0, false);
	                            object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                        } else
	                            object.duration = options.longs === String ? "0" : 0;
	                        object.firstContextBase_64 = "";
	                        object.secondContextBase_64 = "";
	                        object.thirdContextBase_64 = "";
	                        object.isWaitingForAnotherDagTask = false;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.display != null && message.hasOwnProperty("display"))
	                        object.display = message.display;
	                    if (message.dependencies && message.dependencies.length) {
	                        object.dependencies = [];
	                        for (var j = 0; j < message.dependencies.length; ++j)
	                            object.dependencies[j] = $root.org.roylance.yadel.TaskDependency.toObject(message.dependencies[j], options);
	                    }
	                    if (message.dagId != null && message.hasOwnProperty("dagId"))
	                        object.dagId = message.dagId;
	                    if (message.logs && message.logs.length) {
	                        object.logs = [];
	                        for (var j = 0; j < message.logs.length; ++j)
	                            object.logs[j] = $root.org.roylance.yadel.Log.toObject(message.logs[j], options);
	                    }
	                    if (message.executionDate != null && message.hasOwnProperty("executionDate"))
	                        if (typeof message.executionDate === "number")
	                            object.executionDate = options.longs === String ? String(message.executionDate) : message.executionDate;
	                        else
	                            object.executionDate = options.longs === String ? $util.Long.prototype.toString.call(message.executionDate) : options.longs === Number ? new $util.LongBits(message.executionDate.low >>> 0, message.executionDate.high >>> 0).toNumber() : message.executionDate;
	                    if (message.startDate != null && message.hasOwnProperty("startDate"))
	                        if (typeof message.startDate === "number")
	                            object.startDate = options.longs === String ? String(message.startDate) : message.startDate;
	                        else
	                            object.startDate = options.longs === String ? $util.Long.prototype.toString.call(message.startDate) : options.longs === Number ? new $util.LongBits(message.startDate.low >>> 0, message.startDate.high >>> 0).toNumber() : message.startDate;
	                    if (message.endDate != null && message.hasOwnProperty("endDate"))
	                        if (typeof message.endDate === "number")
	                            object.endDate = options.longs === String ? String(message.endDate) : message.endDate;
	                        else
	                            object.endDate = options.longs === String ? $util.Long.prototype.toString.call(message.endDate) : options.longs === Number ? new $util.LongBits(message.endDate.low >>> 0, message.endDate.high >>> 0).toNumber() : message.endDate;
	                    if (message.duration != null && message.hasOwnProperty("duration"))
	                        if (typeof message.duration === "number")
	                            object.duration = options.longs === String ? String(message.duration) : message.duration;
	                        else
	                            object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        object.firstContextBase_64 = message.firstContextBase_64;
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        object.secondContextBase_64 = message.secondContextBase_64;
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        object.thirdContextBase_64 = message.thirdContextBase_64;
	                    if (message.isWaitingForAnotherDagTask != null && message.hasOwnProperty("isWaitingForAnotherDagTask"))
	                        object.isWaitingForAnotherDagTask = message.isWaitingForAnotherDagTask;
	                    if (message.filters && message.filters.length) {
	                        object.filters = [];
	                        for (var j = 0; j < message.filters.length; ++j)
	                            object.filters[j] = $root.org.roylance.yadel.WorkerFilter.toObject(message.filters[j], options);
	                    }
	                    return object;
	                };

	                /**
	                 * Converts this Task to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.Task
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                Task.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return Task;
	            })();

	            yadel.TaskDependency = (function() {

	                /**
	                 * Properties of a TaskDependency.
	                 * @memberof org.roylance.yadel
	                 * @interface ITaskDependency
	                 * @property {string} [id] TaskDependency id
	                 * @property {string} [parentTaskId] TaskDependency parentTaskId
	                 */

	                /**
	                 * Constructs a new TaskDependency.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a TaskDependency.
	                 * @constructor
	                 * @param {org.roylance.yadel.ITaskDependency=} [properties] Properties to set
	                 */
	                function TaskDependency(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * TaskDependency id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @instance
	                 */
	                TaskDependency.prototype.id = "";

	                /**
	                 * TaskDependency parentTaskId.
	                 * @member {string}parentTaskId
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @instance
	                 */
	                TaskDependency.prototype.parentTaskId = "";

	                /**
	                 * Creates a new TaskDependency instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {org.roylance.yadel.ITaskDependency=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.TaskDependency} TaskDependency instance
	                 */
	                TaskDependency.create = function create(properties) {
	                    return new TaskDependency(properties);
	                };

	                /**
	                 * Encodes the specified TaskDependency message. Does not implicitly {@link org.roylance.yadel.TaskDependency.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {org.roylance.yadel.ITaskDependency} message TaskDependency message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                TaskDependency.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.parentTaskId != null && message.hasOwnProperty("parentTaskId"))
	                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.parentTaskId);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified TaskDependency message, length delimited. Does not implicitly {@link org.roylance.yadel.TaskDependency.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {org.roylance.yadel.ITaskDependency} message TaskDependency message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                TaskDependency.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a TaskDependency message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.TaskDependency} TaskDependency
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                TaskDependency.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.TaskDependency();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.parentTaskId = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a TaskDependency message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.TaskDependency} TaskDependency
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                TaskDependency.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a TaskDependency message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                TaskDependency.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.parentTaskId != null && message.hasOwnProperty("parentTaskId"))
	                        if (!$util.isString(message.parentTaskId))
	                            return "parentTaskId: string expected";
	                    return null;
	                };

	                /**
	                 * Creates a TaskDependency message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.TaskDependency} TaskDependency
	                 */
	                TaskDependency.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.TaskDependency)
	                        return object;
	                    var message = new $root.org.roylance.yadel.TaskDependency();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.parentTaskId != null)
	                        message.parentTaskId = String(object.parentTaskId);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a TaskDependency message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @static
	                 * @param {org.roylance.yadel.TaskDependency} message TaskDependency
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                TaskDependency.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.parentTaskId = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.parentTaskId != null && message.hasOwnProperty("parentTaskId"))
	                        object.parentTaskId = message.parentTaskId;
	                    return object;
	                };

	                /**
	                 * Converts this TaskDependency to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.TaskDependency
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                TaskDependency.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return TaskDependency;
	            })();

	            yadel.AddTaskToDag = (function() {

	                /**
	                 * Properties of an AddTaskToDag.
	                 * @memberof org.roylance.yadel
	                 * @interface IAddTaskToDag
	                 * @property {string} [id] AddTaskToDag id
	                 * @property {org.roylance.yadel.ITask} [parentTask] AddTaskToDag parentTask
	                 * @property {org.roylance.yadel.ITask} [newTask] AddTaskToDag newTask
	                 * @property {string} [firstContextBase_64] AddTaskToDag firstContextBase_64
	                 * @property {string} [secondContextBase_64] AddTaskToDag secondContextBase_64
	                 * @property {string} [thirdContextBase_64] AddTaskToDag thirdContextBase_64
	                 */

	                /**
	                 * Constructs a new AddTaskToDag.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents an AddTaskToDag.
	                 * @constructor
	                 * @param {org.roylance.yadel.IAddTaskToDag=} [properties] Properties to set
	                 */
	                function AddTaskToDag(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * AddTaskToDag id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.id = "";

	                /**
	                 * AddTaskToDag parentTask.
	                 * @member {(org.roylance.yadel.ITask|null|undefined)}parentTask
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.parentTask = null;

	                /**
	                 * AddTaskToDag newTask.
	                 * @member {(org.roylance.yadel.ITask|null|undefined)}newTask
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.newTask = null;

	                /**
	                 * AddTaskToDag firstContextBase_64.
	                 * @member {string}firstContextBase_64
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.firstContextBase_64 = "";

	                /**
	                 * AddTaskToDag secondContextBase_64.
	                 * @member {string}secondContextBase_64
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.secondContextBase_64 = "";

	                /**
	                 * AddTaskToDag thirdContextBase_64.
	                 * @member {string}thirdContextBase_64
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 */
	                AddTaskToDag.prototype.thirdContextBase_64 = "";

	                /**
	                 * Creates a new AddTaskToDag instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {org.roylance.yadel.IAddTaskToDag=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.AddTaskToDag} AddTaskToDag instance
	                 */
	                AddTaskToDag.create = function create(properties) {
	                    return new AddTaskToDag(properties);
	                };

	                /**
	                 * Encodes the specified AddTaskToDag message. Does not implicitly {@link org.roylance.yadel.AddTaskToDag.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {org.roylance.yadel.IAddTaskToDag} message AddTaskToDag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                AddTaskToDag.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.parentTask != null && message.hasOwnProperty("parentTask"))
	                        $root.org.roylance.yadel.Task.encode(message.parentTask, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.newTask != null && message.hasOwnProperty("newTask"))
	                        $root.org.roylance.yadel.Task.encode(message.newTask, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.firstContextBase_64);
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.secondContextBase_64);
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.thirdContextBase_64);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified AddTaskToDag message, length delimited. Does not implicitly {@link org.roylance.yadel.AddTaskToDag.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {org.roylance.yadel.IAddTaskToDag} message AddTaskToDag message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                AddTaskToDag.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes an AddTaskToDag message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.AddTaskToDag} AddTaskToDag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                AddTaskToDag.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.AddTaskToDag();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.parentTask = $root.org.roylance.yadel.Task.decode(reader, reader.uint32());
	                            break;
	                        case 3:
	                            message.newTask = $root.org.roylance.yadel.Task.decode(reader, reader.uint32());
	                            break;
	                        case 4:
	                            message.firstContextBase_64 = reader.string();
	                            break;
	                        case 5:
	                            message.secondContextBase_64 = reader.string();
	                            break;
	                        case 6:
	                            message.thirdContextBase_64 = reader.string();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes an AddTaskToDag message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.AddTaskToDag} AddTaskToDag
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                AddTaskToDag.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies an AddTaskToDag message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                AddTaskToDag.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.parentTask != null && message.hasOwnProperty("parentTask")) {
	                        var error = $root.org.roylance.yadel.Task.verify(message.parentTask);
	                        if (error)
	                            return "parentTask." + error;
	                    }
	                    if (message.newTask != null && message.hasOwnProperty("newTask")) {
	                        error = $root.org.roylance.yadel.Task.verify(message.newTask);
	                        if (error)
	                            return "newTask." + error;
	                    }
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        if (!$util.isString(message.firstContextBase_64))
	                            return "firstContextBase_64: string expected";
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        if (!$util.isString(message.secondContextBase_64))
	                            return "secondContextBase_64: string expected";
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        if (!$util.isString(message.thirdContextBase_64))
	                            return "thirdContextBase_64: string expected";
	                    return null;
	                };

	                /**
	                 * Creates an AddTaskToDag message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.AddTaskToDag} AddTaskToDag
	                 */
	                AddTaskToDag.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.AddTaskToDag)
	                        return object;
	                    var message = new $root.org.roylance.yadel.AddTaskToDag();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.parentTask != null) {
	                        if (typeof object.parentTask !== "object")
	                            throw TypeError(".org.roylance.yadel.AddTaskToDag.parentTask: object expected");
	                        message.parentTask = $root.org.roylance.yadel.Task.fromObject(object.parentTask);
	                    }
	                    if (object.newTask != null) {
	                        if (typeof object.newTask !== "object")
	                            throw TypeError(".org.roylance.yadel.AddTaskToDag.newTask: object expected");
	                        message.newTask = $root.org.roylance.yadel.Task.fromObject(object.newTask);
	                    }
	                    if (object.firstContextBase_64 != null)
	                        message.firstContextBase_64 = String(object.firstContextBase_64);
	                    if (object.secondContextBase_64 != null)
	                        message.secondContextBase_64 = String(object.secondContextBase_64);
	                    if (object.thirdContextBase_64 != null)
	                        message.thirdContextBase_64 = String(object.thirdContextBase_64);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from an AddTaskToDag message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @static
	                 * @param {org.roylance.yadel.AddTaskToDag} message AddTaskToDag
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                AddTaskToDag.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.parentTask = null;
	                        object.newTask = null;
	                        object.firstContextBase_64 = "";
	                        object.secondContextBase_64 = "";
	                        object.thirdContextBase_64 = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.parentTask != null && message.hasOwnProperty("parentTask"))
	                        object.parentTask = $root.org.roylance.yadel.Task.toObject(message.parentTask, options);
	                    if (message.newTask != null && message.hasOwnProperty("newTask"))
	                        object.newTask = $root.org.roylance.yadel.Task.toObject(message.newTask, options);
	                    if (message.firstContextBase_64 != null && message.hasOwnProperty("firstContextBase_64"))
	                        object.firstContextBase_64 = message.firstContextBase_64;
	                    if (message.secondContextBase_64 != null && message.hasOwnProperty("secondContextBase_64"))
	                        object.secondContextBase_64 = message.secondContextBase_64;
	                    if (message.thirdContextBase_64 != null && message.hasOwnProperty("thirdContextBase_64"))
	                        object.thirdContextBase_64 = message.thirdContextBase_64;
	                    return object;
	                };

	                /**
	                 * Converts this AddTaskToDag to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.AddTaskToDag
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                AddTaskToDag.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return AddTaskToDag;
	            })();

	            yadel.CompleteTask = (function() {

	                /**
	                 * Properties of a CompleteTask.
	                 * @memberof org.roylance.yadel
	                 * @interface ICompleteTask
	                 * @property {string} [id] CompleteTask id
	                 * @property {org.roylance.yadel.ITask} [task] CompleteTask task
	                 * @property {org.roylance.yadel.IWorkerConfiguration} [workerConfiguration] CompleteTask workerConfiguration
	                 * @property {boolean} [isError] CompleteTask isError
	                 */

	                /**
	                 * Constructs a new CompleteTask.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a CompleteTask.
	                 * @constructor
	                 * @param {org.roylance.yadel.ICompleteTask=} [properties] Properties to set
	                 */
	                function CompleteTask(properties) {
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * CompleteTask id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @instance
	                 */
	                CompleteTask.prototype.id = "";

	                /**
	                 * CompleteTask task.
	                 * @member {(org.roylance.yadel.ITask|null|undefined)}task
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @instance
	                 */
	                CompleteTask.prototype.task = null;

	                /**
	                 * CompleteTask workerConfiguration.
	                 * @member {(org.roylance.yadel.IWorkerConfiguration|null|undefined)}workerConfiguration
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @instance
	                 */
	                CompleteTask.prototype.workerConfiguration = null;

	                /**
	                 * CompleteTask isError.
	                 * @member {boolean}isError
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @instance
	                 */
	                CompleteTask.prototype.isError = false;

	                /**
	                 * Creates a new CompleteTask instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {org.roylance.yadel.ICompleteTask=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.CompleteTask} CompleteTask instance
	                 */
	                CompleteTask.create = function create(properties) {
	                    return new CompleteTask(properties);
	                };

	                /**
	                 * Encodes the specified CompleteTask message. Does not implicitly {@link org.roylance.yadel.CompleteTask.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {org.roylance.yadel.ICompleteTask} message CompleteTask message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                CompleteTask.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.task != null && message.hasOwnProperty("task"))
	                        $root.org.roylance.yadel.Task.encode(message.task, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.workerConfiguration != null && message.hasOwnProperty("workerConfiguration"))
	                        $root.org.roylance.yadel.WorkerConfiguration.encode(message.workerConfiguration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isError);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified CompleteTask message, length delimited. Does not implicitly {@link org.roylance.yadel.CompleteTask.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {org.roylance.yadel.ICompleteTask} message CompleteTask message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                CompleteTask.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a CompleteTask message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.CompleteTask} CompleteTask
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                CompleteTask.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.CompleteTask();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.task = $root.org.roylance.yadel.Task.decode(reader, reader.uint32());
	                            break;
	                        case 3:
	                            message.workerConfiguration = $root.org.roylance.yadel.WorkerConfiguration.decode(reader, reader.uint32());
	                            break;
	                        case 5:
	                            message.isError = reader.bool();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a CompleteTask message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.CompleteTask} CompleteTask
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                CompleteTask.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a CompleteTask message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                CompleteTask.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.task != null && message.hasOwnProperty("task")) {
	                        var error = $root.org.roylance.yadel.Task.verify(message.task);
	                        if (error)
	                            return "task." + error;
	                    }
	                    if (message.workerConfiguration != null && message.hasOwnProperty("workerConfiguration")) {
	                        error = $root.org.roylance.yadel.WorkerConfiguration.verify(message.workerConfiguration);
	                        if (error)
	                            return "workerConfiguration." + error;
	                    }
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        if (typeof message.isError !== "boolean")
	                            return "isError: boolean expected";
	                    return null;
	                };

	                /**
	                 * Creates a CompleteTask message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.CompleteTask} CompleteTask
	                 */
	                CompleteTask.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.CompleteTask)
	                        return object;
	                    var message = new $root.org.roylance.yadel.CompleteTask();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    if (object.task != null) {
	                        if (typeof object.task !== "object")
	                            throw TypeError(".org.roylance.yadel.CompleteTask.task: object expected");
	                        message.task = $root.org.roylance.yadel.Task.fromObject(object.task);
	                    }
	                    if (object.workerConfiguration != null) {
	                        if (typeof object.workerConfiguration !== "object")
	                            throw TypeError(".org.roylance.yadel.CompleteTask.workerConfiguration: object expected");
	                        message.workerConfiguration = $root.org.roylance.yadel.WorkerConfiguration.fromObject(object.workerConfiguration);
	                    }
	                    if (object.isError != null)
	                        message.isError = Boolean(object.isError);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a CompleteTask message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @static
	                 * @param {org.roylance.yadel.CompleteTask} message CompleteTask
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                CompleteTask.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.defaults) {
	                        object.id = "";
	                        object.task = null;
	                        object.workerConfiguration = null;
	                        object.isError = false;
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.task != null && message.hasOwnProperty("task"))
	                        object.task = $root.org.roylance.yadel.Task.toObject(message.task, options);
	                    if (message.workerConfiguration != null && message.hasOwnProperty("workerConfiguration"))
	                        object.workerConfiguration = $root.org.roylance.yadel.WorkerConfiguration.toObject(message.workerConfiguration, options);
	                    if (message.isError != null && message.hasOwnProperty("isError"))
	                        object.isError = message.isError;
	                    return object;
	                };

	                /**
	                 * Converts this CompleteTask to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.CompleteTask
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                CompleteTask.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return CompleteTask;
	            })();

	            yadel.AllDags = (function() {

	                /**
	                 * Properties of an AllDags.
	                 * @memberof org.roylance.yadel
	                 * @interface IAllDags
	                 * @property {Array.<org.roylance.yadel.IDag>} [dags] AllDags dags
	                 * @property {Array.<org.roylance.yadel.IWorkerConfiguration>} [workers] AllDags workers
	                 * @property {boolean} [includeUnprocessed] AllDags includeUnprocessed
	                 * @property {boolean} [includeFileSaved] AllDags includeFileSaved
	                 */

	                /**
	                 * Constructs a new AllDags.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents an AllDags.
	                 * @constructor
	                 * @param {org.roylance.yadel.IAllDags=} [properties] Properties to set
	                 */
	                function AllDags(properties) {
	                    this.dags = [];
	                    this.workers = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * AllDags dags.
	                 * @member {Array.<org.roylance.yadel.IDag>}dags
	                 * @memberof org.roylance.yadel.AllDags
	                 * @instance
	                 */
	                AllDags.prototype.dags = $util.emptyArray;

	                /**
	                 * AllDags workers.
	                 * @member {Array.<org.roylance.yadel.IWorkerConfiguration>}workers
	                 * @memberof org.roylance.yadel.AllDags
	                 * @instance
	                 */
	                AllDags.prototype.workers = $util.emptyArray;

	                /**
	                 * AllDags includeUnprocessed.
	                 * @member {boolean}includeUnprocessed
	                 * @memberof org.roylance.yadel.AllDags
	                 * @instance
	                 */
	                AllDags.prototype.includeUnprocessed = false;

	                /**
	                 * AllDags includeFileSaved.
	                 * @member {boolean}includeFileSaved
	                 * @memberof org.roylance.yadel.AllDags
	                 * @instance
	                 */
	                AllDags.prototype.includeFileSaved = false;

	                /**
	                 * Creates a new AllDags instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {org.roylance.yadel.IAllDags=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.AllDags} AllDags instance
	                 */
	                AllDags.create = function create(properties) {
	                    return new AllDags(properties);
	                };

	                /**
	                 * Encodes the specified AllDags message. Does not implicitly {@link org.roylance.yadel.AllDags.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {org.roylance.yadel.IAllDags} message AllDags message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                AllDags.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.dags != null && message.dags.length)
	                        for (var i = 0; i < message.dags.length; ++i)
	                            $root.org.roylance.yadel.Dag.encode(message.dags[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
	                    if (message.workers != null && message.workers.length)
	                        for (var i = 0; i < message.workers.length; ++i)
	                            $root.org.roylance.yadel.WorkerConfiguration.encode(message.workers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
	                    if (message.includeUnprocessed != null && message.hasOwnProperty("includeUnprocessed"))
	                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeUnprocessed);
	                    if (message.includeFileSaved != null && message.hasOwnProperty("includeFileSaved"))
	                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeFileSaved);
	                    return writer;
	                };

	                /**
	                 * Encodes the specified AllDags message, length delimited. Does not implicitly {@link org.roylance.yadel.AllDags.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {org.roylance.yadel.IAllDags} message AllDags message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                AllDags.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes an AllDags message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.AllDags} AllDags
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                AllDags.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.AllDags();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            if (!(message.dags && message.dags.length))
	                                message.dags = [];
	                            message.dags.push($root.org.roylance.yadel.Dag.decode(reader, reader.uint32()));
	                            break;
	                        case 2:
	                            if (!(message.workers && message.workers.length))
	                                message.workers = [];
	                            message.workers.push($root.org.roylance.yadel.WorkerConfiguration.decode(reader, reader.uint32()));
	                            break;
	                        case 3:
	                            message.includeUnprocessed = reader.bool();
	                            break;
	                        case 4:
	                            message.includeFileSaved = reader.bool();
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes an AllDags message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.AllDags} AllDags
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                AllDags.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies an AllDags message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                AllDags.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.dags != null && message.hasOwnProperty("dags")) {
	                        if (!Array.isArray(message.dags))
	                            return "dags: array expected";
	                        for (var i = 0; i < message.dags.length; ++i) {
	                            var error = $root.org.roylance.yadel.Dag.verify(message.dags[i]);
	                            if (error)
	                                return "dags." + error;
	                        }
	                    }
	                    if (message.workers != null && message.hasOwnProperty("workers")) {
	                        if (!Array.isArray(message.workers))
	                            return "workers: array expected";
	                        for (var i = 0; i < message.workers.length; ++i) {
	                            error = $root.org.roylance.yadel.WorkerConfiguration.verify(message.workers[i]);
	                            if (error)
	                                return "workers." + error;
	                        }
	                    }
	                    if (message.includeUnprocessed != null && message.hasOwnProperty("includeUnprocessed"))
	                        if (typeof message.includeUnprocessed !== "boolean")
	                            return "includeUnprocessed: boolean expected";
	                    if (message.includeFileSaved != null && message.hasOwnProperty("includeFileSaved"))
	                        if (typeof message.includeFileSaved !== "boolean")
	                            return "includeFileSaved: boolean expected";
	                    return null;
	                };

	                /**
	                 * Creates an AllDags message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.AllDags} AllDags
	                 */
	                AllDags.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.AllDags)
	                        return object;
	                    var message = new $root.org.roylance.yadel.AllDags();
	                    if (object.dags) {
	                        if (!Array.isArray(object.dags))
	                            throw TypeError(".org.roylance.yadel.AllDags.dags: array expected");
	                        message.dags = [];
	                        for (var i = 0; i < object.dags.length; ++i) {
	                            if (typeof object.dags[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.AllDags.dags: object expected");
	                            message.dags[i] = $root.org.roylance.yadel.Dag.fromObject(object.dags[i]);
	                        }
	                    }
	                    if (object.workers) {
	                        if (!Array.isArray(object.workers))
	                            throw TypeError(".org.roylance.yadel.AllDags.workers: array expected");
	                        message.workers = [];
	                        for (var i = 0; i < object.workers.length; ++i) {
	                            if (typeof object.workers[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.AllDags.workers: object expected");
	                            message.workers[i] = $root.org.roylance.yadel.WorkerConfiguration.fromObject(object.workers[i]);
	                        }
	                    }
	                    if (object.includeUnprocessed != null)
	                        message.includeUnprocessed = Boolean(object.includeUnprocessed);
	                    if (object.includeFileSaved != null)
	                        message.includeFileSaved = Boolean(object.includeFileSaved);
	                    return message;
	                };

	                /**
	                 * Creates a plain object from an AllDags message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.AllDags
	                 * @static
	                 * @param {org.roylance.yadel.AllDags} message AllDags
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                AllDags.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults) {
	                        object.dags = [];
	                        object.workers = [];
	                    }
	                    if (options.defaults) {
	                        object.includeUnprocessed = false;
	                        object.includeFileSaved = false;
	                    }
	                    if (message.dags && message.dags.length) {
	                        object.dags = [];
	                        for (var j = 0; j < message.dags.length; ++j)
	                            object.dags[j] = $root.org.roylance.yadel.Dag.toObject(message.dags[j], options);
	                    }
	                    if (message.workers && message.workers.length) {
	                        object.workers = [];
	                        for (var j = 0; j < message.workers.length; ++j)
	                            object.workers[j] = $root.org.roylance.yadel.WorkerConfiguration.toObject(message.workers[j], options);
	                    }
	                    if (message.includeUnprocessed != null && message.hasOwnProperty("includeUnprocessed"))
	                        object.includeUnprocessed = message.includeUnprocessed;
	                    if (message.includeFileSaved != null && message.hasOwnProperty("includeFileSaved"))
	                        object.includeFileSaved = message.includeFileSaved;
	                    return object;
	                };

	                /**
	                 * Converts this AllDags to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.AllDags
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                AllDags.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return AllDags;
	            })();

	            yadel.WorkerProperties = (function() {

	                /**
	                 * Properties of a WorkerProperties.
	                 * @memberof org.roylance.yadel
	                 * @interface IWorkerProperties
	                 * @property {string} [id] WorkerProperties id
	                 * @property {org.roylance.yadel.OSBitVersion} [osBitVersion] WorkerProperties osBitVersion
	                 * @property {org.roylance.yadel.OSTypeVersion} [osTypeVersion] WorkerProperties osTypeVersion
	                 * @property {string} [osMajorVersion] WorkerProperties osMajorVersion
	                 * @property {string} [osMinorVersion] WorkerProperties osMinorVersion
	                 * @property {string} [osBuildVersion] WorkerProperties osBuildVersion
	                 * @property {Array.<org.roylance.yadel.IWorkerProperty>} [properties] WorkerProperties properties
	                 */

	                /**
	                 * Constructs a new WorkerProperties.
	                 * @memberof org.roylance.yadel
	                 * @classdesc Represents a WorkerProperties.
	                 * @constructor
	                 * @param {org.roylance.yadel.IWorkerProperties=} [properties] Properties to set
	                 */
	                function WorkerProperties(properties) {
	                    this.properties = [];
	                    if (properties)
	                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                            if (properties[keys[i]] != null)
	                                this[keys[i]] = properties[keys[i]];
	                }

	                /**
	                 * WorkerProperties id.
	                 * @member {string}id
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.id = "";

	                /**
	                 * WorkerProperties osBitVersion.
	                 * @member {org.roylance.yadel.OSBitVersion}osBitVersion
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.osBitVersion = 0;

	                /**
	                 * WorkerProperties osTypeVersion.
	                 * @member {org.roylance.yadel.OSTypeVersion}osTypeVersion
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.osTypeVersion = 0;

	                /**
	                 * WorkerProperties osMajorVersion.
	                 * @member {string}osMajorVersion
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.osMajorVersion = "";

	                /**
	                 * WorkerProperties osMinorVersion.
	                 * @member {string}osMinorVersion
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.osMinorVersion = "";

	                /**
	                 * WorkerProperties osBuildVersion.
	                 * @member {string}osBuildVersion
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.osBuildVersion = "";

	                /**
	                 * WorkerProperties properties.
	                 * @member {Array.<org.roylance.yadel.IWorkerProperty>}properties
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 */
	                WorkerProperties.prototype.properties = $util.emptyArray;

	                /**
	                 * Creates a new WorkerProperties instance using the specified properties.
	                 * @function create
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperties=} [properties] Properties to set
	                 * @returns {org.roylance.yadel.WorkerProperties} WorkerProperties instance
	                 */
	                WorkerProperties.create = function create(properties) {
	                    return new WorkerProperties(properties);
	                };

	                /**
	                 * Encodes the specified WorkerProperties message. Does not implicitly {@link org.roylance.yadel.WorkerProperties.verify|verify} messages.
	                 * @function encode
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperties} message WorkerProperties message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerProperties.encode = function encode(message, writer) {
	                    if (!writer)
	                        writer = $Writer.create();
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.osBitVersion);
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.osTypeVersion);
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.osMajorVersion);
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.osMinorVersion);
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.osBuildVersion);
	                    if (message.properties != null && message.properties.length)
	                        for (var i = 0; i < message.properties.length; ++i)
	                            $root.org.roylance.yadel.WorkerProperty.encode(message.properties[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
	                    return writer;
	                };

	                /**
	                 * Encodes the specified WorkerProperties message, length delimited. Does not implicitly {@link org.roylance.yadel.WorkerProperties.verify|verify} messages.
	                 * @function encodeDelimited
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {org.roylance.yadel.IWorkerProperties} message WorkerProperties message or plain object to encode
	                 * @param {$protobuf.Writer} [writer] Writer to encode to
	                 * @returns {$protobuf.Writer} Writer
	                 */
	                WorkerProperties.encodeDelimited = function encodeDelimited(message, writer) {
	                    return this.encode(message, writer).ldelim();
	                };

	                /**
	                 * Decodes a WorkerProperties message from the specified reader or buffer.
	                 * @function decode
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @param {number} [length] Message length if known beforehand
	                 * @returns {org.roylance.yadel.WorkerProperties} WorkerProperties
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerProperties.decode = function decode(reader, length) {
	                    if (!(reader instanceof $Reader))
	                        reader = $Reader.create(reader);
	                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.org.roylance.yadel.WorkerProperties();
	                    while (reader.pos < end) {
	                        var tag = reader.uint32();
	                        switch (tag >>> 3) {
	                        case 1:
	                            message.id = reader.string();
	                            break;
	                        case 2:
	                            message.osBitVersion = reader.int32();
	                            break;
	                        case 3:
	                            message.osTypeVersion = reader.int32();
	                            break;
	                        case 4:
	                            message.osMajorVersion = reader.string();
	                            break;
	                        case 5:
	                            message.osMinorVersion = reader.string();
	                            break;
	                        case 6:
	                            message.osBuildVersion = reader.string();
	                            break;
	                        case 7:
	                            if (!(message.properties && message.properties.length))
	                                message.properties = [];
	                            message.properties.push($root.org.roylance.yadel.WorkerProperty.decode(reader, reader.uint32()));
	                            break;
	                        default:
	                            reader.skipType(tag & 7);
	                            break;
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Decodes a WorkerProperties message from the specified reader or buffer, length delimited.
	                 * @function decodeDelimited
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                 * @returns {org.roylance.yadel.WorkerProperties} WorkerProperties
	                 * @throws {Error} If the payload is not a reader or valid buffer
	                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                 */
	                WorkerProperties.decodeDelimited = function decodeDelimited(reader) {
	                    if (!(reader instanceof $Reader))
	                        reader = new $Reader(reader);
	                    return this.decode(reader, reader.uint32());
	                };

	                /**
	                 * Verifies a WorkerProperties message.
	                 * @function verify
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {Object.<string,*>} message Plain object to verify
	                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                 */
	                WorkerProperties.verify = function verify(message) {
	                    if (typeof message !== "object" || message === null)
	                        return "object expected";
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        if (!$util.isString(message.id))
	                            return "id: string expected";
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        switch (message.osBitVersion) {
	                        default:
	                            return "osBitVersion: enum value expected";
	                        case 0:
	                        case 1:
	                            break;
	                        }
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        switch (message.osTypeVersion) {
	                        default:
	                            return "osTypeVersion: enum value expected";
	                        case 0:
	                        case 1:
	                        case 2:
	                        case 3:
	                        case 4:
	                        case 5:
	                        case 6:
	                            break;
	                        }
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        if (!$util.isString(message.osMajorVersion))
	                            return "osMajorVersion: string expected";
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        if (!$util.isString(message.osMinorVersion))
	                            return "osMinorVersion: string expected";
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        if (!$util.isString(message.osBuildVersion))
	                            return "osBuildVersion: string expected";
	                    if (message.properties != null && message.hasOwnProperty("properties")) {
	                        if (!Array.isArray(message.properties))
	                            return "properties: array expected";
	                        for (var i = 0; i < message.properties.length; ++i) {
	                            var error = $root.org.roylance.yadel.WorkerProperty.verify(message.properties[i]);
	                            if (error)
	                                return "properties." + error;
	                        }
	                    }
	                    return null;
	                };

	                /**
	                 * Creates a WorkerProperties message from a plain object. Also converts values to their respective internal types.
	                 * @function fromObject
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {Object.<string,*>} object Plain object
	                 * @returns {org.roylance.yadel.WorkerProperties} WorkerProperties
	                 */
	                WorkerProperties.fromObject = function fromObject(object) {
	                    if (object instanceof $root.org.roylance.yadel.WorkerProperties)
	                        return object;
	                    var message = new $root.org.roylance.yadel.WorkerProperties();
	                    if (object.id != null)
	                        message.id = String(object.id);
	                    switch (object.osBitVersion) {
	                    case "V_64_BIT_VERSION":
	                    case 0:
	                        message.osBitVersion = 0;
	                        break;
	                    case "V_32_BIT_VERSION":
	                    case 1:
	                        message.osBitVersion = 1;
	                        break;
	                    }
	                    switch (object.osTypeVersion) {
	                    case "MAC_OS_TYPE_VERSION":
	                    case 0:
	                        message.osTypeVersion = 0;
	                        break;
	                    case "WIN_OS_TYPE_VERSION":
	                    case 1:
	                        message.osTypeVersion = 1;
	                        break;
	                    case "UBUNTU_OS_TYPE_VERSION":
	                    case 2:
	                        message.osTypeVersion = 2;
	                        break;
	                    case "CENTOS_OS_TYPE_VERSION":
	                    case 3:
	                        message.osTypeVersion = 3;
	                        break;
	                    case "FEDORA_OS_TYPE_VERSION":
	                    case 4:
	                        message.osTypeVersion = 4;
	                        break;
	                    case "REDHAT_OS_TYPE_VERSION":
	                    case 5:
	                        message.osTypeVersion = 5;
	                        break;
	                    case "LINUX_OS_TYPE_VERSION":
	                    case 6:
	                        message.osTypeVersion = 6;
	                        break;
	                    }
	                    if (object.osMajorVersion != null)
	                        message.osMajorVersion = String(object.osMajorVersion);
	                    if (object.osMinorVersion != null)
	                        message.osMinorVersion = String(object.osMinorVersion);
	                    if (object.osBuildVersion != null)
	                        message.osBuildVersion = String(object.osBuildVersion);
	                    if (object.properties) {
	                        if (!Array.isArray(object.properties))
	                            throw TypeError(".org.roylance.yadel.WorkerProperties.properties: array expected");
	                        message.properties = [];
	                        for (var i = 0; i < object.properties.length; ++i) {
	                            if (typeof object.properties[i] !== "object")
	                                throw TypeError(".org.roylance.yadel.WorkerProperties.properties: object expected");
	                            message.properties[i] = $root.org.roylance.yadel.WorkerProperty.fromObject(object.properties[i]);
	                        }
	                    }
	                    return message;
	                };

	                /**
	                 * Creates a plain object from a WorkerProperties message. Also converts values to other types if specified.
	                 * @function toObject
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @static
	                 * @param {org.roylance.yadel.WorkerProperties} message WorkerProperties
	                 * @param {$protobuf.IConversionOptions} [options] Conversion options
	                 * @returns {Object.<string,*>} Plain object
	                 */
	                WorkerProperties.toObject = function toObject(message, options) {
	                    if (!options)
	                        options = {};
	                    var object = {};
	                    if (options.arrays || options.defaults)
	                        object.properties = [];
	                    if (options.defaults) {
	                        object.id = "";
	                        object.osBitVersion = options.enums === String ? "V_64_BIT_VERSION" : 0;
	                        object.osTypeVersion = options.enums === String ? "MAC_OS_TYPE_VERSION" : 0;
	                        object.osMajorVersion = "";
	                        object.osMinorVersion = "";
	                        object.osBuildVersion = "";
	                    }
	                    if (message.id != null && message.hasOwnProperty("id"))
	                        object.id = message.id;
	                    if (message.osBitVersion != null && message.hasOwnProperty("osBitVersion"))
	                        object.osBitVersion = options.enums === String ? $root.org.roylance.yadel.OSBitVersion[message.osBitVersion] : message.osBitVersion;
	                    if (message.osTypeVersion != null && message.hasOwnProperty("osTypeVersion"))
	                        object.osTypeVersion = options.enums === String ? $root.org.roylance.yadel.OSTypeVersion[message.osTypeVersion] : message.osTypeVersion;
	                    if (message.osMajorVersion != null && message.hasOwnProperty("osMajorVersion"))
	                        object.osMajorVersion = message.osMajorVersion;
	                    if (message.osMinorVersion != null && message.hasOwnProperty("osMinorVersion"))
	                        object.osMinorVersion = message.osMinorVersion;
	                    if (message.osBuildVersion != null && message.hasOwnProperty("osBuildVersion"))
	                        object.osBuildVersion = message.osBuildVersion;
	                    if (message.properties && message.properties.length) {
	                        object.properties = [];
	                        for (var j = 0; j < message.properties.length; ++j)
	                            object.properties[j] = $root.org.roylance.yadel.WorkerProperty.toObject(message.properties[j], options);
	                    }
	                    return object;
	                };

	                /**
	                 * Converts this WorkerProperties to JSON.
	                 * @function toJSON
	                 * @memberof org.roylance.yadel.WorkerProperties
	                 * @instance
	                 * @returns {Object.<string,*>} JSON object
	                 */
	                WorkerProperties.prototype.toJSON = function toJSON() {
	                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                };

	                return WorkerProperties;
	            })();

	            return yadel;
	        })();

	        return roylance;
	    })();

	    return org;
	})();

	module.exports = $root;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	// minimal library entry point.

	"use strict";
	module.exports = __webpack_require__(6);


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var protobuf = exports;

	/**
	 * Build type, one of `"full"`, `"light"` or `"minimal"`.
	 * @name build
	 * @type {string}
	 * @const
	 */
	protobuf.build = "minimal";

	// Serialization
	protobuf.Writer       = __webpack_require__(7);
	protobuf.BufferWriter = __webpack_require__(17);
	protobuf.Reader       = __webpack_require__(18);
	protobuf.BufferReader = __webpack_require__(19);

	// Utility
	protobuf.util         = __webpack_require__(8);
	protobuf.rpc          = __webpack_require__(20);
	protobuf.roots        = __webpack_require__(22);
	protobuf.configure    = configure;

	/* istanbul ignore next */
	/**
	 * Reconfigures the library according to the environment.
	 * @returns {undefined}
	 */
	function configure() {
	    protobuf.Reader._configure(protobuf.BufferReader);
	    protobuf.util._configure();
	}

	// Configure serialization
	protobuf.Writer._configure(protobuf.BufferWriter);
	configure();


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = Writer;

	var util      = __webpack_require__(8);

	var BufferWriter; // cyclic

	var LongBits  = util.LongBits,
	    base64    = util.base64,
	    utf8      = util.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = util.Buffer
	    ? function create_buffer_setup() {
	        return (Writer.create = function create_buffer() {
	            return new BufferWriter();
	        })();
	    }
	    /* istanbul ignore next */
	    : function create_array() {
	        return new Writer();
	    };

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new util.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (util.Array !== Array)
	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(util.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(util.float.writeDoubleLE, 8, value);
	};

	var writeBytes = util.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (util.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	var util = exports;

	// used to return a Promise where callback is omitted
	util.asPromise = __webpack_require__(9);

	// converts to / from base64 encoded strings
	util.base64 = __webpack_require__(10);

	// base class of rpc.Service
	util.EventEmitter = __webpack_require__(11);

	// float handling accross browsers
	util.float = __webpack_require__(12);

	// requires modules optionally and hides the call from bundlers
	util.inquire = __webpack_require__(13);

	// converts to / from utf8 encoded strings
	util.utf8 = __webpack_require__(14);

	// provides a node-like buffer pool in the browser
	util.pool = __webpack_require__(15);

	// utility to work with the low and high bits of a 64 bit value
	util.LongBits = __webpack_require__(16);

	/**
	 * An immuable empty array.
	 * @memberof util
	 * @type {Array.<*>}
	 * @const
	 */
	util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

	/**
	 * An immutable empty object.
	 * @type {Object}
	 * @const
	 */
	util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

	/**
	 * Whether running within node or not.
	 * @memberof util
	 * @type {boolean}
	 * @const
	 */
	util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

	/**
	 * Tests if the specified value is an integer.
	 * @function
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is an integer
	 */
	util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
	    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
	};

	/**
	 * Tests if the specified value is a string.
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is a string
	 */
	util.isString = function isString(value) {
	    return typeof value === "string" || value instanceof String;
	};

	/**
	 * Tests if the specified value is a non-null object.
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is a non-null object
	 */
	util.isObject = function isObject(value) {
	    return value && typeof value === "object";
	};

	/**
	 * Checks if a property on a message is considered to be present.
	 * This is an alias of {@link util.isSet}.
	 * @function
	 * @param {Object} obj Plain object or message instance
	 * @param {string} prop Property name
	 * @returns {boolean} `true` if considered to be present, otherwise `false`
	 */
	util.isset =

	/**
	 * Checks if a property on a message is considered to be present.
	 * @param {Object} obj Plain object or message instance
	 * @param {string} prop Property name
	 * @returns {boolean} `true` if considered to be present, otherwise `false`
	 */
	util.isSet = function isSet(obj, prop) {
	    var value = obj[prop];
	    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
	        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
	    return false;
	};

	/**
	 * Any compatible Buffer instance.
	 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
	 * @interface Buffer
	 * @extends Uint8Array
	 */

	/**
	 * Node's Buffer class if available.
	 * @type {Constructor<Buffer>}
	 */
	util.Buffer = (function() {
	    try {
	        var Buffer = util.inquire("buffer").Buffer;
	        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
	        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
	    } catch (e) {
	        /* istanbul ignore next */
	        return null;
	    }
	})();

	// Internal alias of or polyfull for Buffer.from.
	util._Buffer_from = null;

	// Internal alias of or polyfill for Buffer.allocUnsafe.
	util._Buffer_allocUnsafe = null;

	/**
	 * Creates a new buffer of whatever type supported by the environment.
	 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
	 * @returns {Uint8Array|Buffer} Buffer
	 */
	util.newBuffer = function newBuffer(sizeOrArray) {
	    /* istanbul ignore next */
	    return typeof sizeOrArray === "number"
	        ? util.Buffer
	            ? util._Buffer_allocUnsafe(sizeOrArray)
	            : new util.Array(sizeOrArray)
	        : util.Buffer
	            ? util._Buffer_from(sizeOrArray)
	            : typeof Uint8Array === "undefined"
	                ? sizeOrArray
	                : new Uint8Array(sizeOrArray);
	};

	/**
	 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
	 * @type {Constructor<Uint8Array>}
	 */
	util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

	/**
	 * Any compatible Long instance.
	 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
	 * @interface Long
	 * @property {number} low Low bits
	 * @property {number} high High bits
	 * @property {boolean} unsigned Whether unsigned or not
	 */

	/**
	 * Long.js's Long class if available.
	 * @type {Constructor<Long>}
	 */
	util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

	/**
	 * Regular expression used to verify 2 bit (`bool`) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key2Re = /^true|false|0|1$/;

	/**
	 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

	/**
	 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

	/**
	 * Converts a number or long to an 8 characters long hash string.
	 * @param {Long|number} value Value to convert
	 * @returns {string} Hash
	 */
	util.longToHash = function longToHash(value) {
	    return value
	        ? util.LongBits.from(value).toHash()
	        : util.LongBits.zeroHash;
	};

	/**
	 * Converts an 8 characters long hash string to a long or number.
	 * @param {string} hash Hash
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long|number} Original value
	 */
	util.longFromHash = function longFromHash(hash, unsigned) {
	    var bits = util.LongBits.fromHash(hash);
	    if (util.Long)
	        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
	    return bits.toNumber(Boolean(unsigned));
	};

	/**
	 * Merges the properties of the source object into the destination object.
	 * @memberof util
	 * @param {Object.<string,*>} dst Destination object
	 * @param {Object.<string,*>} src Source object
	 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
	 * @returns {Object.<string,*>} Destination object
	 */
	function merge(dst, src, ifNotSet) { // used by converters
	    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
	        if (dst[keys[i]] === undefined || !ifNotSet)
	            dst[keys[i]] = src[keys[i]];
	    return dst;
	}

	util.merge = merge;

	/**
	 * Converts the first character of a string to lower case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.lcFirst = function lcFirst(str) {
	    return str.charAt(0).toLowerCase() + str.substring(1);
	};

	/**
	 * Creates a custom error constructor.
	 * @memberof util
	 * @param {string} name Error name
	 * @returns {Constructor<Error>} Custom error constructor
	 */
	function newError(name) {

	    function CustomError(message, properties) {

	        if (!(this instanceof CustomError))
	            return new CustomError(message, properties);

	        // Error.call(this, message);
	        // ^ just returns a new error instance because the ctor can be called as a function

	        Object.defineProperty(this, "message", { get: function() { return message; } });

	        /* istanbul ignore next */
	        if (Error.captureStackTrace) // node
	            Error.captureStackTrace(this, CustomError);
	        else
	            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

	        if (properties)
	            merge(this, properties);
	    }

	    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

	    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

	    CustomError.prototype.toString = function toString() {
	        return this.name + ": " + this.message;
	    };

	    return CustomError;
	}

	util.newError = newError;

	/**
	 * Constructs a new protocol error.
	 * @classdesc Error subclass indicating a protocol specifc error.
	 * @memberof util
	 * @extends Error
	 * @template T extends Message<T>
	 * @constructor
	 * @param {string} message Error message
	 * @param {Object.<string,*>} [properties] Additional properties
	 * @example
	 * try {
	 *     MyMessage.decode(someBuffer); // throws if required fields are missing
	 * } catch (e) {
	 *     if (e instanceof ProtocolError && e.instance)
	 *         console.log("decoded so far: " + JSON.stringify(e.instance));
	 * }
	 */
	util.ProtocolError = newError("ProtocolError");

	/**
	 * So far decoded message instance.
	 * @name util.ProtocolError#instance
	 * @type {Message<T>}
	 */

	/**
	 * A OneOf getter as returned by {@link util.oneOfGetter}.
	 * @typedef OneOfGetter
	 * @type {function}
	 * @returns {string|undefined} Set field name, if any
	 */

	/**
	 * Builds a getter for a oneof's present field name.
	 * @param {string[]} fieldNames Field names
	 * @returns {OneOfGetter} Unbound getter
	 */
	util.oneOfGetter = function getOneOf(fieldNames) {
	    var fieldMap = {};
	    for (var i = 0; i < fieldNames.length; ++i)
	        fieldMap[fieldNames[i]] = 1;

	    /**
	     * @returns {string|undefined} Set field name, if any
	     * @this Object
	     * @ignore
	     */
	    return function() { // eslint-disable-line consistent-return
	        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
	            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
	                return keys[i];
	    };
	};

	/**
	 * A OneOf setter as returned by {@link util.oneOfSetter}.
	 * @typedef OneOfSetter
	 * @type {function}
	 * @param {string|undefined} value Field name
	 * @returns {undefined}
	 */

	/**
	 * Builds a setter for a oneof's present field name.
	 * @param {string[]} fieldNames Field names
	 * @returns {OneOfSetter} Unbound setter
	 */
	util.oneOfSetter = function setOneOf(fieldNames) {

	    /**
	     * @param {string} name Field name
	     * @returns {undefined}
	     * @this Object
	     * @ignore
	     */
	    return function(name) {
	        for (var i = 0; i < fieldNames.length; ++i)
	            if (fieldNames[i] !== name)
	                delete this[fieldNames[i]];
	    };
	};

	/**
	 * Default conversion options used for {@link Message#toJSON} implementations.
	 *
	 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
	 *
	 * - Longs become strings
	 * - Enums become string keys
	 * - Bytes become base64 encoded strings
	 * - (Sub-)Messages become plain objects
	 * - Maps become plain objects with all string keys
	 * - Repeated fields become arrays
	 * - NaN and Infinity for float and double fields become strings
	 *
	 * @type {IConversionOptions}
	 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
	 */
	util.toJSONOptions = {
	    longs: String,
	    enums: String,
	    bytes: String,
	    json: true
	};

	util._configure = function() {
	    var Buffer = util.Buffer;
	    /* istanbul ignore if */
	    if (!Buffer) {
	        util._Buffer_from = util._Buffer_allocUnsafe = null;
	        return;
	    }
	    // because node 4.x buffers are incompatible & immutable
	    // see: https://github.com/dcodeIO/protobuf.js/pull/665
	    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
	        /* istanbul ignore next */
	        function Buffer_from(value, encoding) {
	            return new Buffer(value, encoding);
	        };
	    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
	        /* istanbul ignore next */
	        function Buffer_allocUnsafe(size) {
	            return new Buffer(size);
	        };
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * A minimal base64 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var base64 = exports;

	/**
	 * Calculates the byte length of a base64 encoded string.
	 * @param {string} string Base64 encoded string
	 * @returns {number} Byte length
	 */
	base64.length = function length(string) {
	    var p = string.length;
	    if (!p)
	        return 0;
	    var n = 0;
	    while (--p % 4 > 1 && string.charAt(p) === "=")
	        ++n;
	    return Math.ceil(string.length * 3) / 4 - n;
	};

	// Base64 encoding table
	var b64 = new Array(64);

	// Base64 decoding table
	var s64 = new Array(123);

	// 65..90, 97..122, 48..57, 43, 47
	for (var i = 0; i < 64;)
	    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

	/**
	 * Encodes a buffer to a base64 encoded string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} Base64 encoded string
	 */
	base64.encode = function encode(buffer, start, end) {
	    var parts = null,
	        chunk = [];
	    var i = 0, // output index
	        j = 0, // goto index
	        t;     // temporary
	    while (start < end) {
	        var b = buffer[start++];
	        switch (j) {
	            case 0:
	                chunk[i++] = b64[b >> 2];
	                t = (b & 3) << 4;
	                j = 1;
	                break;
	            case 1:
	                chunk[i++] = b64[t | b >> 4];
	                t = (b & 15) << 2;
	                j = 2;
	                break;
	            case 2:
	                chunk[i++] = b64[t | b >> 6];
	                chunk[i++] = b64[b & 63];
	                j = 0;
	                break;
	        }
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (j) {
	        chunk[i++] = b64[t];
	        chunk[i++] = 61;
	        if (j === 1)
	            chunk[i++] = 61;
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	var invalidEncoding = "invalid encoding";

	/**
	 * Decodes a base64 encoded string to a buffer.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Number of bytes written
	 * @throws {Error} If encoding is invalid
	 */
	base64.decode = function decode(string, buffer, offset) {
	    var start = offset;
	    var j = 0, // goto index
	        t;     // temporary
	    for (var i = 0; i < string.length;) {
	        var c = string.charCodeAt(i++);
	        if (c === 61 && j > 1)
	            break;
	        if ((c = s64[c]) === undefined)
	            throw Error(invalidEncoding);
	        switch (j) {
	            case 0:
	                t = c;
	                j = 1;
	                break;
	            case 1:
	                buffer[offset++] = t << 2 | (c & 48) >> 4;
	                t = c;
	                j = 2;
	                break;
	            case 2:
	                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
	                t = c;
	                j = 3;
	                break;
	            case 3:
	                buffer[offset++] = (t & 3) << 6 | c;
	                j = 0;
	                break;
	        }
	    }
	    if (j === 1)
	        throw Error(invalidEncoding);
	    return offset - start;
	};

	/**
	 * Tests if the specified string appears to be base64 encoded.
	 * @param {string} string String to test
	 * @returns {boolean} `true` if probably base64 encoded, otherwise false
	 */
	base64.test = function test(string) {
	    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
	};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}


/***/ }),
/* 13 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * A minimal UTF8 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var utf8 = exports;

	/**
	 * Calculates the UTF8 byte length of a string.
	 * @param {string} string String
	 * @returns {number} Byte length
	 */
	utf8.length = function utf8_length(string) {
	    var len = 0,
	        c = 0;
	    for (var i = 0; i < string.length; ++i) {
	        c = string.charCodeAt(i);
	        if (c < 128)
	            len += 1;
	        else if (c < 2048)
	            len += 2;
	        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
	            ++i;
	            len += 4;
	        } else
	            len += 3;
	    }
	    return len;
	};

	/**
	 * Reads UTF8 bytes as a string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} String read
	 */
	utf8.read = function utf8_read(buffer, start, end) {
	    var len = end - start;
	    if (len < 1)
	        return "";
	    var parts = null,
	        chunk = [],
	        i = 0, // char offset
	        t;     // temporary
	    while (start < end) {
	        t = buffer[start++];
	        if (t < 128)
	            chunk[i++] = t;
	        else if (t > 191 && t < 224)
	            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
	        else if (t > 239 && t < 365) {
	            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
	            chunk[i++] = 0xD800 + (t >> 10);
	            chunk[i++] = 0xDC00 + (t & 1023);
	        } else
	            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	/**
	 * Writes a string as UTF8 bytes.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Bytes written
	 */
	utf8.write = function utf8_write(string, buffer, offset) {
	    var start = offset,
	        c1, // character 1
	        c2; // character 2
	    for (var i = 0; i < string.length; ++i) {
	        c1 = string.charCodeAt(i);
	        if (c1 < 128) {
	            buffer[offset++] = c1;
	        } else if (c1 < 2048) {
	            buffer[offset++] = c1 >> 6       | 192;
	            buffer[offset++] = c1       & 63 | 128;
	        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
	            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
	            ++i;
	            buffer[offset++] = c1 >> 18      | 240;
	            buffer[offset++] = c1 >> 12 & 63 | 128;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        } else {
	            buffer[offset++] = c1 >> 12      | 224;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        }
	    }
	    return offset - start;
	};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = LongBits;

	var util = __webpack_require__(8);

	/**
	 * Constructs new long bits.
	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
	 * @memberof util
	 * @constructor
	 * @param {number} lo Low 32 bits, unsigned
	 * @param {number} hi High 32 bits, unsigned
	 */
	function LongBits(lo, hi) {

	    // note that the casts below are theoretically unnecessary as of today, but older statically
	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

	    /**
	     * Low bits.
	     * @type {number}
	     */
	    this.lo = lo >>> 0;

	    /**
	     * High bits.
	     * @type {number}
	     */
	    this.hi = hi >>> 0;
	}

	/**
	 * Zero bits.
	 * @memberof util.LongBits
	 * @type {util.LongBits}
	 */
	var zero = LongBits.zero = new LongBits(0, 0);

	zero.toNumber = function() { return 0; };
	zero.zzEncode = zero.zzDecode = function() { return this; };
	zero.length = function() { return 1; };

	/**
	 * Zero hash.
	 * @memberof util.LongBits
	 * @type {string}
	 */
	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

	/**
	 * Constructs new long bits from the specified number.
	 * @param {number} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.fromNumber = function fromNumber(value) {
	    if (value === 0)
	        return zero;
	    var sign = value < 0;
	    if (sign)
	        value = -value;
	    var lo = value >>> 0,
	        hi = (value - lo) / 4294967296 >>> 0;
	    if (sign) {
	        hi = ~hi >>> 0;
	        lo = ~lo >>> 0;
	        if (++lo > 4294967295) {
	            lo = 0;
	            if (++hi > 4294967295)
	                hi = 0;
	        }
	    }
	    return new LongBits(lo, hi);
	};

	/**
	 * Constructs new long bits from a number, long or string.
	 * @param {Long|number|string} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.from = function from(value) {
	    if (typeof value === "number")
	        return LongBits.fromNumber(value);
	    if (util.isString(value)) {
	        /* istanbul ignore else */
	        if (util.Long)
	            value = util.Long.fromString(value);
	        else
	            return LongBits.fromNumber(parseInt(value, 10));
	    }
	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
	};

	/**
	 * Converts this long bits to a possibly unsafe JavaScript number.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {number} Possibly unsafe number
	 */
	LongBits.prototype.toNumber = function toNumber(unsigned) {
	    if (!unsigned && this.hi >>> 31) {
	        var lo = ~this.lo + 1 >>> 0,
	            hi = ~this.hi     >>> 0;
	        if (!lo)
	            hi = hi + 1 >>> 0;
	        return -(lo + hi * 4294967296);
	    }
	    return this.lo + this.hi * 4294967296;
	};

	/**
	 * Converts this long bits to a long.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long} Long
	 */
	LongBits.prototype.toLong = function toLong(unsigned) {
	    return util.Long
	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
	        /* istanbul ignore next */
	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
	};

	var charCodeAt = String.prototype.charCodeAt;

	/**
	 * Constructs new long bits from the specified 8 characters long hash.
	 * @param {string} hash Hash
	 * @returns {util.LongBits} Bits
	 */
	LongBits.fromHash = function fromHash(hash) {
	    if (hash === zeroHash)
	        return zero;
	    return new LongBits(
	        ( charCodeAt.call(hash, 0)
	        | charCodeAt.call(hash, 1) << 8
	        | charCodeAt.call(hash, 2) << 16
	        | charCodeAt.call(hash, 3) << 24) >>> 0
	    ,
	        ( charCodeAt.call(hash, 4)
	        | charCodeAt.call(hash, 5) << 8
	        | charCodeAt.call(hash, 6) << 16
	        | charCodeAt.call(hash, 7) << 24) >>> 0
	    );
	};

	/**
	 * Converts this long bits to a 8 characters long hash.
	 * @returns {string} Hash
	 */
	LongBits.prototype.toHash = function toHash() {
	    return String.fromCharCode(
	        this.lo        & 255,
	        this.lo >>> 8  & 255,
	        this.lo >>> 16 & 255,
	        this.lo >>> 24      ,
	        this.hi        & 255,
	        this.hi >>> 8  & 255,
	        this.hi >>> 16 & 255,
	        this.hi >>> 24
	    );
	};

	/**
	 * Zig-zag encodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzEncode = function zzEncode() {
	    var mask =   this.hi >> 31;
	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Zig-zag decodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzDecode = function zzDecode() {
	    var mask = -(this.lo & 1);
	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Calculates the length of this longbits when encoded as a varint.
	 * @returns {number} Length
	 */
	LongBits.prototype.length = function length() {
	    var part0 =  this.lo,
	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
	        part2 =  this.hi >>> 24;
	    return part2 === 0
	         ? part1 === 0
	           ? part0 < 16384
	             ? part0 < 128 ? 1 : 2
	             : part0 < 2097152 ? 3 : 4
	           : part1 < 16384
	             ? part1 < 128 ? 5 : 6
	             : part1 < 2097152 ? 7 : 8
	         : part2 < 128 ? 9 : 10;
	};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = BufferWriter;

	// extends Writer
	var Writer = __webpack_require__(7);
	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

	var util = __webpack_require__(8);

	var Buffer = util.Buffer;

	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter() {
	    Writer.call(this);
	}

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Buffer} Buffer
	 */
	BufferWriter.alloc = function alloc_buffer(size) {
	    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
	};

	var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
	    ? function writeBytesBuffer_set(val, buf, pos) {
	        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	                           // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytesBuffer_copy(val, buf, pos) {
	        if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	        else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	    };

	/**
	 * @override
	 */
	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
	    if (util.isString(value))
	        value = util._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        util.utf8.write(val, buf, pos);
	    else
	        buf.utf8Write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter.prototype.string = function write_string_buffer(value) {
	    var len = Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = Reader;

	var util      = __webpack_require__(8);

	var BufferReader; // cyclic

	var LongBits  = util.LongBits,
	    utf8      = util.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = util.Buffer
	    ? function create_buffer_setup(buffer) {
	        return (Reader.create = function create_buffer(buffer) {
	            return util.Buffer.isBuffer(buffer)
	                ? new BufferReader(buffer)
	                /* istanbul ignore next */
	                : create_array(buffer);
	        })(buffer);
	    }
	    /* istanbul ignore next */
	    : create_array;

	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);
	    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
	        ? new this.buf.constructor(0)
	        : this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            do { // eslint-disable-line no-constant-condition
	                if ((wireType = this.uint32() & 7) === 4)
	                    break;
	                this.skipType(wireType);
	            } while (true);
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;

	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    util.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = BufferReader;

	// extends Reader
	var Reader = __webpack_require__(18);
	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

	var util = __webpack_require__(8);

	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader(buffer) {
	    Reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	/* istanbul ignore else */
	if (util.Buffer)
	    BufferReader.prototype._slice = util.Buffer.prototype.slice;

	/**
	 * @override
	 */
	BufferReader.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Streaming RPC helpers.
	 * @namespace
	 */
	var rpc = exports;

	/**
	 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
	 * @typedef RPCImpl
	 * @type {function}
	 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
	 * @param {Uint8Array} requestData Request data
	 * @param {RPCImplCallback} callback Callback function
	 * @returns {undefined}
	 * @example
	 * function rpcImpl(method, requestData, callback) {
	 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
	 *         throw Error("no such method");
	 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
	 *         callback(err, responseData);
	 *     });
	 * }
	 */

	/**
	 * Node-style callback as used by {@link RPCImpl}.
	 * @typedef RPCImplCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
	 * @returns {undefined}
	 */

	rpc.Service = __webpack_require__(21);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = Service;

	var util = __webpack_require__(8);

	// Extends EventEmitter
	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    util.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = {};

	/**
	 * Named roots.
	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
	 * Can also be used manually to make roots available accross modules.
	 * @name roots
	 * @type {Object.<string,Root>}
	 * @example
	 * // pbjs -r myroot -o compiled.js ...
	 *
	 * // in another module:
	 * require("./compiled.js");
	 *
	 * // in any subsequent module:
	 * var root = protobuf.roots["myroot"];
	 */


/***/ }),
/* 23 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var DagService = (function () {
	    function DagService() {
	    }
	    DagService.prototype.buildTreeVisualization = function (dag) {
	        var arrange = "LR";
	        var g = new dagreD3.graphlib.Graph();
	        g.setGraph({});
	        g.setDefaultEdgeLabel(function () { return {}; });
	        for (var nodeIdx in dag.nodes) {
	            var node = dag.nodes[nodeIdx];
	            if (node.isCompleted) {
	                g.setNode(node.id, { label: node.display, style: "fill: green" });
	            }
	            else if (node.isProcessing) {
	                g.setNode(node.id, { label: node.display, style: "fill: gray" });
	            }
	            else if (node.isError) {
	                g.setNode(node.id, { label: node.display, style: "fill: red" });
	            }
	            else {
	                g.setNode(node.id, { label: node.display, style: "fill: whitesmoke" });
	            }
	        }
	        for (var edgeIdx in dag.edges) {
	            g.setEdge(dag.edges[edgeIdx].nodeId_2, dag.edges[edgeIdx].nodeId_1);
	        }
	        var render = new dagreD3.render();
	        // todo: parameterize this more
	        var svg = d3.select("svg"), svgGroup = svg.append("g");
	        //noinspection TypeScriptValidateTypes
	        render(d3.select("svg g"), g);
	    };
	    return DagService;
	}());
	exports.DagService = DagService;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var HttpExecute = (function () {
	    function HttpExecute(httpService) {
	        this.httpPost = "POST";
	        this.httpService = httpService;
	    }
	    HttpExecute.prototype.performPost = function (url, data, onSuccess, onError) {
	        this.httpService({
	            url: url,
	            method: this.httpPost,
	            data: data
	        }).then(function (response) {
	            onSuccess(response.data);
	        }, function (response) {
	            onError(response.data);
	        });
	    };
	    return HttpExecute;
	}());
	exports.HttpExecute = HttpExecute;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// THIS FILE WAS AUTO-GENERATED. DO NOT ALTER!
	var ReportService_1 = __webpack_require__(26);
	var HttpExecute_1 = __webpack_require__(24);
	var FurtherAngularSetup_1 = __webpack_require__(1);
	var app = angular.module('jsapp', [
	    "ngRoute"
	]);
	app.factory("httpExecute", function ($window, $http) {
	    return new HttpExecute_1.HttpExecute($http);
	});
	app.factory("reportService", function (httpExecute) {
	    return new ReportService_1.ReportService(httpExecute);
	});
	FurtherAngularSetup_1.furtherAngularSetup(app);


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var ReportService = (function () {
	    function ReportService(httpExecute) {
	        this.httpExecute = httpExecute;
	    }
	    ReportService.prototype.delete_dag = function (request, onSuccess, onError) {
	        var self = this;
	        this.httpExecute.performPost("/rest/report/delete-dag", request, onSuccess, onError);
	    };
	    ReportService.prototype.current = function (request, onSuccess, onError) {
	        var self = this;
	        this.httpExecute.performPost("/rest/report/current", request, onSuccess, onError);
	    };
	    ReportService.prototype.get_dag_status = function (request, onSuccess, onError) {
	        var self = this;
	        this.httpExecute.performPost("/rest/report/get-dag-status", request, onSuccess, onError);
	    };
	    return ReportService;
	}());
	exports.ReportService = ReportService;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;


/***/ })
/******/ ]);